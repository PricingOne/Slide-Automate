<!DOCTYPE html>
<html>
<head>
<title>Slides documantion.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="slide-automation-tool-documentation"><strong>Slide Automation Tool Documentation</strong></h1>
<h2 id="slides-sections">Slides Sections</h2>
<ul>
<li><a href="#landscape-section">Landscape</a></li>
<li><a href="#pricing-section">Pricing</a></li>
<li><a href="#ppa-section">PPA</a></li>
<li><a href="#mixassortment-section">Mix&amp;Assortment</a></li>
<li><a href="#promotion-section">Promotion</a></li>
<li><a href="#Financials-section">Financials</a></li>
<li><a href="#Pricing_CBC-section">Pricing_CBC</a></li>
<li><a href="#Innovation_CBC-section">Innovation_CBC</a></li>
</ul>
<hr>
<h2 id="landscape-section">Landscape Section</h2>
<h3 id="introduction">Introduction</h3>
<p>In the slide automation landscape: from13 slide base we create 5 decks</p>
<pre><code>![1732020538845](image/Slidesdocumantion/1732020538845.png)
</code></pre>
<ol>
<li>
<p>Landscape Market(trend-Concent-growth)&amp;ValAvgPrice Slides:</p>
<ul>
<li>Market Trends Analysis</li>
<li>Market Concentration</li>
<li>Market growth contributors</li>
<li>Value Sales &amp; Avg Price</li>
</ul>
</li>
<li>
<p>Landscape ShareGrowth Slides:</p>
<ul>
<li>Share and Growth by Manufacturer/Brands</li>
<li>Share and Growth By Manufacturer</li>
<li>Momentum Analysis</li>
</ul>
</li>
<li>
<p>Landscape Category(Trend-Overview)Slides :</p>
<ul>
<li>Category Trends</li>
<li>Share Evolution index analysis</li>
<li>Category Overview</li>
</ul>
</li>
<li>
<p>Landscape Output WO CB Slides:</p>
<ul>
<li>Market Trends Analysis</li>
<li>Market Concentration</li>
<li>Share and Growth by Manufacturer/Brands</li>
<li>Share and Growth By Manufacturer</li>
</ul>
</li>
<li>
<p>Landscape RPVM Slides:</p>
<ul>
<li>Revenue by Price vs. Volume vs. Mix analysis</li>
</ul>
</li>
</ol>
<hr>
<h3 id="project-steps">Project Steps</h3>
<ul>
<li>Project Flow
![Project Flow](../Slides Documantion/duplication_Steps.PNG)</li>
</ul>
<ul>
<li><a href="#step-1-import-libraries-we-use">Step 1: Import Libraries we use</a></li>
<li><a href="#step-2-modified-data-frames">Step 2: modified Data frames: cleaning and preprocessing the data frames</a></li>
<li><a href="#step-3-write-functions-to-create-slides">Step 3: Write Functions to Create Slides: Define functions to Automatically generate slides based on the base slides</a></li>
<li><a href="#step-4-duplicate-slides">Step 4: Duplicate Slides: Use functions or methods to duplicate existing slides as needed for the presentation.</a></li>
<li><a href="#step-5-replace-data-in-slides">Step 5: Replace Data in Slides: update information from the cleaned data frames to slides</a></li>
<li><a href="#step-6-save-presentation">Step 6: Save Presentation</a></li>
</ul>
<hr>
<h4 id="step-1-import-libraries-we-use"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/generalFunctions.ipynb">Step 1: Import Libraries we use </a></h4>
<h5 id="ex-libraries-we-use">Ex: Libraries we use</h5>
<ul>
<li>This script sets up an environment for working with PowerPoint presentations, data manipulation, filesystem operations, and COM (Component Object Model) object access.</li>
<li>It imports necessary modules such as 'pptx' for PowerPoint automation, 'win32com' for COM object access and Windows automation, 'pandas' and 'numpy' for data manipulation,</li>
<li>'pathlib' for working with filesystem paths, 're' for regular expression operations, and various other modules for general-purpose tasks like file operations and timing functions.</li>
<li>By importing these modules, the script prepares itself for tasks such as creating or modifying PowerPoint presentations, analyzing data using pandas and numpy, interacting</li>
<li>with the Windows environment using win32com, and performing filesystem operations using shutil and os. Overall, this script provides a comprehensive setup for automating tasks</li>
<li>related to PowerPoint presentations and general-purpose Python programming.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Import necessary module for working with PowerPoint presentations</span>
<span class="hljs-keyword">from</span> pptx <span class="hljs-keyword">import</span> Presentation
<span class="hljs-comment"># Import the win32com.client module, aliasing it as win32 for convenience</span>
<span class="hljs-keyword">import</span> win32com.client <span class="hljs-keyword">as</span> win32
<span class="hljs-comment"># Import pandas for data manipulation and analysis</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># Import numpy for numerical computing</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># Import the Path class from pathlib for working with filesystem paths</span>
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-comment"># Import re for regular expression operations</span>
<span class="hljs-keyword">import</span> re
<span class="hljs-comment"># Import sys for access to interpreter-related functions</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-comment"># Import time for various time-related functions</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-comment"># Assign win32.constants to a shorter alias win32c for easier access</span>
win32c = win32.constants
<span class="hljs-comment"># Import shutil for high-level file operations</span>
<span class="hljs-keyword">import</span> shutil
<span class="hljs-comment"># Import os for operating system dependent functionality</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-comment"># Import win32com.client again for COM object and functions access</span>
<span class="hljs-keyword">import</span> win32com.client
<span class="hljs-comment"># Import warnings for warning control functionality</span>
<span class="hljs-keyword">import</span> warnings
</div></code></pre>
<hr>
<h4 id="step-2-modified-data-frames"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Landscape%20slide%20duplicate/Landscape%20duplicate.ipynb">Step 2: modified Data frames</a></h4>
<ul>
<li>This function takes a dictionary of dataframes and a category type as input.</li>
<li>It iterates over each dataframe in the dictionary and performs cleaning operations,</li>
<li>such as renaming columns, removing unwanted rows, converting data types, and</li>
<li>separating totals from the main data. The cleaned dataframes and totals are</li>
<li>stored in separate dictionaries. Finally, it returns two dictionaries:</li>
<li>one containing cleaned sector segment data and the other containing totals.</li>
</ul>
<h5 id="parameters">Parameters:</h5>
<ul>
<li>
<ul>
<li>inputdic: A dictionary of dataframes where each dataframe represents  data.</li>
</ul>
</li>
</ul>
<h5 id="returns">Returns:</h5>
<ul>
<li>
<ul>
<li>outputdic: A dictionary containing cleaned sector segment dataframes for each sector.</li>
</ul>
</li>
<li>
<ul>
<li>totaloutputdic: A dictionary containing totals dataframes for each sector.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">secsegclean</span><span class="hljs-params">(inputdic)</span>:</span>
    outputdic={}
    totaloutputdic={}
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> inputdic.keys():
        t = inputdic[s].copy()
        t=DetectHeader(t).fillna(<span class="hljs-number">0</span>)
        mod = t[(~t[t.columns[<span class="hljs-number">0</span>]].astype(str).str.contains(<span class="hljs-string">'Grand Total'</span>))]
        mod = mod.sort_values([col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> mod.columns <span class="hljs-keyword">if</span> <span class="hljs-string">'Value Share'</span> <span class="hljs-keyword">in</span> col], ascending=<span class="hljs-literal">False</span>)
        tot = t[(t[t.columns[<span class="hljs-number">0</span>]].astype(str).str.contains(<span class="hljs-string">'Grand Total'</span>))]
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mod.empty:
            outputdic[s] = mod
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tot.empty:
            totaloutputdic[s] = tot
    <span class="hljs-keyword">return</span> outputdic,totaloutputdic
</div></code></pre>
<hr>
<h5 id="example-input-dataframe-before-clean">Example: input dataframe before clean</h5>
<p><img src="image/Slidesdocumantion/1732017928516.png" alt="1732017928516"></p>
<h5 id="example-how-to-call-the-function--show-the-dataframe-output">Example: How to call the function &amp; show the DataFrame output</h5>
<p><img src="image/Slidesdocumantion/1732018071216.png" alt="1732018071216"></p>
<hr>
<h4 id="step-3-write-functions-to-create-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Landscape%20Replacement%20Function.ipynb">Step 3: Write Functions to Create Slides</a></h4>
<hr>
<p>To create slides we need some function
Example:Market Trends slides
![Market Trends slide](../Slides Documantion/market trends slide.png)</p>
<hr>
<ul>
<li>
<p><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Landscape%20slide%20duplicate/Landscape%20Replacement%20Function.ipynb">Totals_Table_Fill</a>: function populates a table on a slide with totals data from a specified dataframe. It formats the text in the cells, including font size, font name, and alignment.</p>
<ul>
<li>It takes Parameters:
table (Table): Table shape in the slide.
list_duplicates (list): List of duplicate names for identifying slides.
df_totals (dict): Dictionary of total DataFrames for each duplicate name.
cols (list): Columns in the DataFrame.
slidenum (int): Slide number.</li>
<li>Returns:
Table: Updated table shape.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Totals_Table_Fill</span><span class="hljs-params">(table, list_duplicates, df_totals, cols, slidenum)</span>:</span>
   
    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> enumerate(table.rows):
        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> j, cell <span class="hljs-keyword">in</span> enumerate(row.cells):
                cell.text = str(round(df_totals[list_duplicates[slidenum]][cols].iloc[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>][j] / <span class="hljs-number">1000000</span>, <span class="hljs-number">1</span> ))
                cell.text_frame.paragraphs[<span class="hljs-number">0</span>].runs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">10</span>)
                cell.text_frame.paragraphs[<span class="hljs-number">0</span>].runs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Book'</span>
                cell.text_frame.paragraphs[<span class="hljs-number">0</span>].alignment = PP_ALIGN.CENTER
    <span class="hljs-keyword">return</span> table
</div></code></pre>
<ul>
<li><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Landscape%20Replacement%20Function.ipynb">Column_Chart_Fill</a>:function customizes a column chart on a slide by filling series with specific colors based on their names and adding formatted data labels to each point in the series
<ul>
<li>It takes Parameters:
chart (Chart): Chart shape in the slide.
scope (list): List of scope names.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Column_Chart_Fill</span><span class="hljs-params">(chart, scope)</span>:</span>
   
    client_colors = [RGBColor(<span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">75</span>), RGBColor(<span class="hljs-number">0</span>, <span class="hljs-number">108</span>, <span class="hljs-number">109</span>), RGBColor(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">151</span>), RGBColor(<span class="hljs-number">126</span>, <span class="hljs-number">202</span>, <span class="hljs-number">196</span>), RGBColor(<span class="hljs-number">153</span>, <span class="hljs-number">199</span>, <span class="hljs-number">197</span>), RGBColor(<span class="hljs-number">178</span>, <span class="hljs-number">223</span>, <span class="hljs-number">220</span>)]
    gray_colors = [RGBColor(<span class="hljs-number">217</span>, <span class="hljs-number">217</span>, <span class="hljs-number">217</span>), RGBColor(<span class="hljs-number">191</span>, <span class="hljs-number">191</span>, <span class="hljs-number">191</span>), RGBColor(<span class="hljs-number">166</span>, <span class="hljs-number">166</span>, <span class="hljs-number">166</span>), RGBColor(<span class="hljs-number">155</span>, <span class="hljs-number">152</span>, <span class="hljs-number">152</span>), RGBColor(<span class="hljs-number">127</span>, <span class="hljs-number">127</span>, <span class="hljs-number">127</span>)]

    <span class="hljs-keyword">for</span> i, series <span class="hljs-keyword">in</span> enumerate(chart.series):
        <span class="hljs-keyword">if</span> series.name <span class="hljs-keyword">in</span> scope:
            series.format.fill.solid()
            series.format.fill.fore_color.rgb = client_colors[i <span class="hljs-keyword">if</span> i &lt; len(client_colors) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>]
        <span class="hljs-keyword">else</span>:
            series.format.fill.solid()
            series.format.fill.fore_color.rgb = gray_colors[i <span class="hljs-keyword">if</span> i &lt; len(gray_colors) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>]               
        <span class="hljs-keyword">for</span> j, point <span class="hljs-keyword">in</span> enumerate(series.points):
            data_label = point.data_label
            data_label.has_text_frame = <span class="hljs-literal">True</span>
            data_label.text_frame.text =  str(round(series.values[j], <span class="hljs-number">1</span>))
            data_label.text_frame.paragraphs[<span class="hljs-number">0</span>].runs[<span class="hljs-number">0</span>].font.color.rgb = RGBColor(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)
</div></code></pre>
<hr>
<ul>
<li>
<p><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Landscape%20slide%20duplicate/Landscape%20Replacement%20Function.ipynb">Markete_Trends function</a>, which automates the creation and updating of market trend analysis slides in a PowerPoint presentation. It fills the slides with charts and tables using data from provided dataframes. The function processes each slide based on a list of duplicate names, adding relevant data and formatting to charts and tables. It supports customization through parameters like position offset and slide grouping criteria. This function is useful for generating detailed, data-driven presentations on market trends, enhancing efficiency and consistency in reporting.</p>
<ul>
<li>It takes Parameters:
prs (Presentation): PowerPoint presentation object.
list_duplicates (list): List of duplicate names for identifying slides.
modified_df (dict): Dictionary of modified DataFrames for each duplicate name.
df_totals (dict): Dictionary of total DataFrames for each duplicate name.
scope (list): List of scope names.
position (int, optional): Position offset for slides. Defaults to 0.
slide_by (str, optional): Slide grouping criteria. Defaults to ''.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Market_Trends</span><span class="hljs-params">(prs, list_duplicates, modified_df, df_totals, scope, position=<span class="hljs-number">0</span>, slide_by=<span class="hljs-string">''</span>)</span>:</span>
   
    <span class="hljs-keyword">for</span> slidenum <span class="hljs-keyword">in</span> range(len(list_duplicates)): 
        shapes = prs.slides[slidenum + position].shapes
        charts = []
        tables = []
        title = shapes.title.text
        shapes[<span class="hljs-number">4</span>].text = data_source  
        shapes[<span class="hljs-number">5</span>].text = <span class="hljs-string">f'Market Trends Analysis | By <span class="hljs-subst">{slide_by}</span> | '</span> + list_duplicates[slidenum] + <span class="hljs-string">' | Year over Year'</span>
        shapes[<span class="hljs-number">5</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.bold = <span class="hljs-literal">True</span>
 
        <span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes:
            <span class="hljs-keyword">if</span> shape.has_chart:
                charts.append(shape)
            <span class="hljs-keyword">if</span> shape.has_table:
                tables.append(shape)

        <span class="hljs-keyword">for</span> chartnum <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):
            chart = charts[chartnum].chart
            table = tables[chartnum].table
            chart_data = CategoryChartData()
            chart_data.categories = [<span class="hljs-string">'2021'</span>, <span class="hljs-string">'2022'</span>, <span class="hljs-string">'YTD 2023'</span>]
  
            volume_cols = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> modified_df[list_duplicates[slidenum]].columns[modified_df[list_duplicates[slidenum]].columns.str.contains(<span class="hljs-string">f'<span class="hljs-subst">{slide_by}</span>|Volume Sales'</span>)]]
            value_cols = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> modified_df[list_duplicates[slidenum]].columns[(modified_df[list_duplicates[slidenum]].columns.str.contains(<span class="hljs-string">f'<span class="hljs-subst">{slide_by}</span>|Value Sales'</span>)) &amp; ~(modified_df[list_duplicates[slidenum]].columns.str.contains(<span class="hljs-string">'IYA'</span>))]]
    
            <span class="hljs-keyword">if</span> chartnum == <span class="hljs-number">0</span>:  
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(modified_df[list_duplicates[slidenum]].shape[<span class="hljs-number">0</span>]):
                    series_name = modified_df[list_duplicates[slidenum]][volume_cols].iloc[i, <span class="hljs-number">0</span>]
                    number = modified_df[list_duplicates[slidenum]][volume_cols].iloc[i, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>] / <span class="hljs-number">1000000</span>  
                    series = chart_data.add_series(series_name, number)
                    chart.replace_data(chart_data)
                    Column_Chart_Fill(chart, scope)
                Totals_Table_Fill(table, list_duplicates, df_totals, volume_cols, slidenum)
  
            <span class="hljs-keyword">elif</span> chartnum == <span class="hljs-number">1</span>:
                value_cols = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> modified_df[list_duplicates[slidenum]].columns[(modified_df[list_duplicates[slidenum]].columns.str.contains(<span class="hljs-string">f'<span class="hljs-subst">{slide_by}</span>|Value Sales'</span>)) &amp; ~(modified_df[list_duplicates[slidenum]].columns.str.contains(<span class="hljs-string">'IYA'</span>))]]
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(modified_df[list_duplicates[slidenum]].shape[<span class="hljs-number">0</span>]):
                    series_name = modified_df[list_duplicates[slidenum]][value_cols].iloc[i, <span class="hljs-number">0</span>]
                    number = modified_df[list_duplicates[slidenum]][value_cols].iloc[i, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>] / <span class="hljs-number">1000000</span>  
                    series = chart_data.add_series(series_name, number)
                    chart.replace_data(chart_data)
                    Column_Chart_Fill(chart, scope)
                Totals_Table_Fill(table, list_duplicates, df_totals, value_cols, slidenum)

</div></code></pre>
<hr>
<h4 id="step-4-duplicate-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Landscape%20slide%20duplicate/Landscape%20duplicate.ipynb">Step 4: Duplicate Slides</a></h4>
<ul>
<li>prepares data and configurations for generating market analysis slides in a PowerPoint presentation. It creates index and duplication lists dynamically based on the presence of segment data and the number of data keys in various dictionaries. These lists are used to control the slide generation process. The script also defines a comprehensive list of section names for organizing slide titles, ensuring each slide is labeled appropriately based on its content. This setup allows for automated, consistent, and dynamic creation of market trend analysis slides, which is particularly useful for large presentations with multiple sections and varying data inputs.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># This script prepares index and duplication lists for generating PowerPoint slides</span>
<span class="hljs-comment"># with various market trends and growth analysis. It dynamically adjusts based on the presence</span>
<span class="hljs-comment"># of segment data and compiles a list of section names for slide titles.</span>

<span class="hljs-comment"># Generate index list based on the presence of segments and section numbers</span>
index = [
    *[<span class="hljs-number">0</span>] * (<span class="hljs-number">4</span> <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">3</span>),  <span class="hljs-comment"># Index for manufacturer and brand slides</span>
    *[<span class="hljs-number">1</span>] * (<span class="hljs-number">4</span> <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">3</span>),  <span class="hljs-comment"># Index for sector slides</span>
    *[<span class="hljs-number">2</span>] * (<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>),  <span class="hljs-comment"># Index for segment slides</span>
    *[<span class="hljs-number">2</span>] * section_number,          <span class="hljs-comment"># Index for additional sections</span>
    *[<span class="hljs-number">3</span>] * (<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>),  <span class="hljs-comment"># Index for additional segment slides</span>
    *[<span class="hljs-number">3</span>] * section_number,          <span class="hljs-comment"># Index for additional sections</span>
    <span class="hljs-number">4</span>,                              <span class="hljs-comment"># Index for specific slide</span>
    *sectorIndex * <span class="hljs-number">2</span>,               <span class="hljs-comment"># Index for sector details</span>
    *segmentIndex * <span class="hljs-number">2</span>,              <span class="hljs-comment"># Index for segment details</span>
    <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                        <span class="hljs-comment"># Fixed indices for specific slides</span>
]

<span class="hljs-comment"># Generate duplication list based on the presence of segments and data keys</span>
duplication = [
    len(modified_manuf_dfs_new.keys()),       <span class="hljs-comment"># Number of manufacturer data keys</span>
    len(modified_brands_share_new.keys()),    <span class="hljs-comment"># Number of brand share data keys</span>
    len(modified_sectors_dfs_new.keys()),     <span class="hljs-comment"># Number of sector data keys</span>
    len(modified_segment_dfs_new.keys()) <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>,  <span class="hljs-comment"># Number of segment data keys if segments exist</span>
    len(modified_manuf_dfs_new.keys()),       <span class="hljs-comment"># Repeated for next section</span>
    len(modified_brands_share_new.keys()),    <span class="hljs-comment"># Repeated for next section</span>
    len(modified_sectors_dfs_new.keys()),     <span class="hljs-comment"># Repeated for next section</span>
    len(modified_segment_dfs_new.keys()) <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>,  <span class="hljs-comment"># Repeated for next section if segments exist</span>
    len(modified_sectors_P12M_new.keys()),    <span class="hljs-comment"># Number of sectors data keys for P12M</span>
    len(modified_segment_P12M_new.keys()) <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>,  <span class="hljs-comment"># Number of segments data keys for P12M if segments exist</span>
    *duplication_num,                         <span class="hljs-comment"># Additional duplication numbers</span>
    len(modified_sectors_clients_new.keys()), <span class="hljs-comment"># Number of sector client data keys</span>
    len(modified_segment_clients_new.keys()) <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-comment"># Number of segment client data keys if segments exist</span>
    *duplication_num_Avg,                     <span class="hljs-comment"># Additional average duplication numbers</span>
    len(modified_manuf_P12M_new.keys()),      <span class="hljs-comment"># Number of manufacturer data keys for P12M</span>
    len(sharGrowthDf_sec.keys()),             <span class="hljs-comment"># Number of sector share growth data keys</span>
    len(sharGrowthDf_sec.keys()),             <span class="hljs-comment"># Repeated for next section</span>
    len(sharGrowthDf_seg.keys()) <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>,  <span class="hljs-comment"># Number of segment share growth data keys if segments exist</span>
    len(sharGrowthDf_seg.keys()) <span class="hljs-keyword">if</span> segments <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>,  <span class="hljs-comment"># Repeated if segments exist</span>
    len(modified_calendar_new.keys()),        <span class="hljs-comment"># Number of calendar data keys</span>
    len(modified_brands_evolution_sorted_new.keys()),  <span class="hljs-comment"># Number of sorted brand evolution data keys</span>
    len(categories_overview_dfs_new.keys())   <span class="hljs-comment"># Number of category overview data keys</span>
]

<span class="hljs-comment"># Remove zeros from duplication list</span>
duplication = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> duplication <span class="hljs-keyword">if</span> item != <span class="hljs-number">0</span>]

<span class="hljs-comment"># Define section names for each slide group</span>
section_names_slide1 = [<span class="hljs-string">"Market Trends by Manufacturer"</span>, <span class="hljs-string">"Market Trends by Brands"</span>, <span class="hljs-string">"Market Trends by Sectors"</span>] + ([<span class="hljs-string">"Market Trends by Segments"</span>] <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [])
section_names_slide2 = [<span class="hljs-string">"Market Concentraion By Manufacturer"</span>, <span class="hljs-string">"Market Concentration By Brands"</span>, <span class="hljs-string">"Market Concentration By Sectors"</span>] + ([<span class="hljs-string">"Market Concentration By Segments"</span>] <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [])
section_names_slide3 = [<span class="hljs-string">"Market Growth By Sectors"</span>] + ([<span class="hljs-string">"Market Growth By Segments"</span>] <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> []) + [*section_name_Growth]
section_names_slide4 = [<span class="hljs-string">"Value Vs AvgPrice By Sectors"</span>] + ([<span class="hljs-string">"Value Vs AvgPrice By Segments"</span>] <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> []) + [*section_name_Avg]
section_names_slide5 = [<span class="hljs-string">'Share and Growth By Manufacturer/Brands'</span>]
section_names_slide6 = [<span class="hljs-string">'Share And Growth By Manufacturer By Sector'</span>, <span class="hljs-string">'Share And Growth By Brands By Sector'</span>] + ([<span class="hljs-string">'Share And Growth By Manufacturer By Segment'</span>, <span class="hljs-string">'Share And Growth By Brands By Segment'</span>] <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [])
section_names_slide7 = [<span class="hljs-string">"Category Trends"</span>]
section_names_slide8 = [<span class="hljs-string">'Share Evolution By Brand'</span>]
section_names_slide9 = [<span class="hljs-string">"Category Overview"</span>]

<span class="hljs-comment"># Combine all section names into a single list</span>
section_names = [
    *section_names_slide1, *section_names_slide2, *section_names_slide3,
    *section_names_slide4, *section_names_slide5, *section_names_slide6,
    *section_names_slide7, *section_names_slide8, *section_names_slide9
]

</div></code></pre>
<hr>
<h4 id="step-5-replace-data-in-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Landscape%20slide%20duplicate/Landscape%20duplicate.ipynb">Step 5: Replace Data in Slides</a></h4>
<ul>
<li>This script uses the Market_Trends function to generate market trend analysis slides in a PowerPoint presentation for various categories such as Top Companies, Top Brands, Sectors, and Segments. It initializes a position counter p and increments it after each call to ensure the slides are added sequentially. The calculate_position function is used to determine the correct position for each set of slides, allowing for dynamic and organized slide generation based on the provided data dictionaries and scope lists. This approach enables efficient creation of comprehensive market analysis presentations.</li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-comment">#  calls the Market_Trends function to generate PowerPoint slides</span>
<span class="hljs-comment"># for different categories (Top Companies, Top Brands, Sector, Segment) and</span>
<span class="hljs-comment"># updates the position variable for each call to ensure slides are generated in the correct order.</span>

p=<span class="hljs-number">0</span>
Market_Trends(prs, list(modified_manuf_dfs_new.keys()), modified_manuf_dfs_new, modified_manuf_totals_new, client_manuf ,position = calculate_position(p), slide_by = <span class="hljs-string">'Top Companies'</span>)
p+=<span class="hljs-number">1</span>
Market_Trends(prs, list(modified_brands_share_new.keys()), modified_brands_share_new, modified_brands_totals_new, client_brands ,position =calculate_position(p), slide_by = <span class="hljs-string">'Top Brands'</span>)
p+=<span class="hljs-number">1</span>
Market_Trends(prs, list(modified_sectors_dfs_new.keys()), modified_sectors_dfs_new, sectors_totals_new, sectors ,position = calculate_position(p), slide_by = <span class="hljs-string">'Sector'</span>)
p+=<span class="hljs-number">1</span>
<span class="hljs-keyword">if</span> len(segments)!=<span class="hljs-number">0</span>:
    Market_Trends(prs, list(modified_segment_dfs_new.keys()), modified_segment_dfs_new, segment_totals_new, segments ,position = calculate_position(p), slide_by = <span class="hljs-string">'Segment'</span>)
    p+=<span class="hljs-number">1</span>
</div></code></pre>
<hr>
<h4 id="step-6-save-presentation"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Landscape%20slide%20duplicate/Landscape%20duplicate.ipynb">Step 6: Save Presentation</a></h4>
<ul>
<li>performs two main tasks: saving the current PowerPoint presentation to a file and opening that file using the PowerPoint application. The outputPath variable is constructed using the current working directory, ensuring the presentation is saved in the correct location. After saving the presentation, the script uses win32com.client to dispatch the PowerPoint application and open the saved presentation. This automation allows for seamless transition from generating the presentation to viewing or editing it in PowerPoint, streamlining the workflow for creating market analysis slides.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># This script saves the generated PowerPoint presentation to a specified path</span>
<span class="hljs-comment"># and then opens the saved presentation using the PowerPoint application.</span>

<span class="hljs-comment"># Define the output path for the PowerPoint presentation</span>
outputPath = os.getcwd() + <span class="hljs-string">"\\Landscape output.pptx"</span>

<span class="hljs-comment"># Save the PowerPoint presentation to the specified output path</span>
prs.save(outputPath)

<span class="hljs-comment"># Initialize the PowerPoint application using win32com client</span>
app = win32.Dispatch(<span class="hljs-string">"PowerPoint.Application"</span>)

<span class="hljs-comment"># Open the saved PowerPoint presentation</span>
presentation = app.Presentations.Open(outputPath)
</div></code></pre>
<hr>
<h5 id="exmarket-trends-slide-output-after-replacement-data">Ex:Market Trends Slide OutPut After Replacement Data</h5>
<p>![Market Trends OutPut](../Slides Documantion/market trends output.png)</p>
<hr>
<h2 id="pricing-section">Pricing  Section</h2>
<h3 id="introduction">Introduction</h3>
<p>In the slide automation pricing : from12 slide base we create 5 decks</p>
<pre><code>![1732021356685](image/Slidesdocumantion/1732021356685.png)
</code></pre>
<ol>
<li>
<p>Pricing Output Slides:</p>
<ul>
<li>Price Positioning Analysis</li>
<li>Share and Growth By Brands(<strong>Leadership Table</strong>)</li>
<li>Value Sales Vs Avg Price</li>
</ul>
</li>
<li>
<p>Pricing  Avg&amp;Shelf Price Output Slides:</p>
<ul>
<li>Avg Price/Vol</li>
<li>Shelf Price/Vol</li>
</ul>
</li>
<li>
<p>Pricing Price Point Output Slides :</p>
<ul>
<li>Price Point Distribution Analysis by product</li>
<li>Price Point Comparison Analysis by Product</li>
<li>Price Point Distribution Analysis by brand</li>
<li>Price Point Distribution by brand by Sector</li>
</ul>
</li>
<li>
<p>Pricing Correlation Output Slides:</p>
<ul>
<li>Price Correlation Analysis P3Y</li>
<li>Price Correlation Analysis P12M</li>
</ul>
</li>
<li>
<p>Pricing not_forcing_CB_Output Slides</p>
<ul>
<li>Price Positioning Analysis</li>
<li>Share and Growth By Brands(<strong>Leadership Table</strong>)</li>
<li>Price Point Distribution Analysis by brand</li>
</ul>
</li>
</ol>
<hr>
<h3 id="project-steps">Project Steps</h3>
<ul>
<li>Project Flow
![Project Flow](../Slides Documantion/duplication_Steps.PNG)</li>
</ul>
<ul>
<li><a href="#step-1-import-libraries">Step 1: Import Libraries we use</a></li>
<li><a href="#step-2-modified-data-frame">Step 2: modified Data frames: cleaning and preprocessing the data frames</a></li>
<li><a href="#step-3-write-functions-to-create-slide">Step 3: Write Functions to Create Slides: Define functions to dynamically generate slides based on the base slides</a></li>
<li><a href="#step-4-duplicate-slides">Step 4: Duplicate Slides: Use functions or methods to duplicate existing slides as needed for the presentation.</a></li>
<li><a href="#step-5-replace-data-in-slide">Step 5: Replace Data in Slide: update information from the cleaned data frames to slides</a></li>
<li><a href="#step-6-save-presentation">Step 6: Save Presentation</a></li>
</ul>
<hr>
<h4 id="step-1-import-libraries-we-use"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/generalFunctions.ipynb">Step 1: Import Libraries we use </a></h4>
<h5 id="ex-libraries-we-use">Ex: Libraries we use</h5>
<ul>
<li>This script sets up an environment for working with PowerPoint presentations, data manipulation, filesystem operations, and COM (Component Object Model) object access.</li>
<li>It imports necessary modules such as 'pptx' for PowerPoint automation, 'win32com' for COM object access and Windows automation, 'pandas' and 'numpy' for data manipulation,</li>
<li>'pathlib' for working with filesystem paths, 're' for regular expression operations, and various other modules for general-purpose tasks like file operations and timing functions.</li>
<li>By importing these modules, the script prepares itself for tasks such as creating or modifying PowerPoint presentations, analyzing data using pandas and numpy, interacting</li>
<li>with the Windows environment using win32com, and performing filesystem operations using shutil and os. Overall, this script provides a comprehensive setup for automating tasks</li>
<li>related to PowerPoint presentations and general-purpose Python programming.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Import necessary module for working with PowerPoint presentations</span>
<span class="hljs-keyword">from</span> pptx <span class="hljs-keyword">import</span> Presentation
<span class="hljs-comment"># Import the win32com.client module, aliasing it as win32 for convenience</span>
<span class="hljs-keyword">import</span> win32com.client <span class="hljs-keyword">as</span> win32
<span class="hljs-comment"># Import pandas for data manipulation and analysis</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># Import numpy for numerical computing</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># Import the Path class from pathlib for working with filesystem paths</span>
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-comment"># Import re for regular expression operations</span>
<span class="hljs-keyword">import</span> re
<span class="hljs-comment"># Import sys for access to interpreter-related functions</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-comment"># Import time for various time-related functions</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-comment"># Assign win32.constants to a shorter alias win32c for easier access</span>
win32c = win32.constants
<span class="hljs-comment"># Import shutil for high-level file operations</span>
<span class="hljs-keyword">import</span> shutil
<span class="hljs-comment"># Import os for operating system dependent functionality</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-comment"># Import win32com.client again for COM object and functions access</span>
<span class="hljs-keyword">import</span> win32com.client
<span class="hljs-comment"># Import warnings for warning control functionality</span>
<span class="hljs-keyword">import</span> warnings
</div></code></pre>
<hr>
<h4 id="step-2-modified-data-frame"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Pricing%20slide%20duplicate/Pricing%20duplicate.ipynb">Step 2: modified Data frame</a></h4>
<h5 id="ex-input-dataframes-before-cleaning">EX: input dataframes before cleaning</h5>
<p>![data frame before cleaning](../Slides Documantion/Pricing dataframe input.png)</p>
<hr>
<h6 id="cleaning-code">cleaning Code</h6>
<ul>
<li>This code processes a dictionary of DataFrames, modified_price_positioning_sorted, by performing a series of operations on each DataFrame. Specifically, it iterates over each key in the dictionary, makes a copy of the DataFrame to avoid altering the original, filters out rows where the 'Top Brands' column has the value 'Others', replaces all NaN values with 0, and then updates the dictionary with the modified DataFrame. This ensures that the DataFrames only include data from specified brands and that missing values are handled appropriately.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Iterate over each key in the dictionary 'modified_price_positioning_sorted'</span>
<span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> modified_price_positioning_sorted.keys():
  
    <span class="hljs-comment"># Create a copy of the DataFrame associated with the current key to avoid modifying the original data</span>
    df = modified_price_positioning_sorted[k].copy()
  
    <span class="hljs-comment"># Filter out rows where the 'Top Brands' column has the value 'Others'</span>
    df = df[df[<span class="hljs-string">'Top Brands'</span>] != <span class="hljs-string">'Others'</span>]
  
    <span class="hljs-comment"># Replace all NaN values in the DataFrame with 0</span>
    df = df.replace(np.nan, <span class="hljs-number">0</span>)
  
    <span class="hljs-comment"># Update the dictionary with the modified DataFrame</span>
    modified_price_positioning_sorted[k] = df

</div></code></pre>
<h6 id="data-frame-after-cleaning">Data frame after cleaning</h6>
<p>![data frame after cleaning ](../Slides Documantion/Pricing dataframe output.png)</p>
<hr>
<h4 id="step-3-write-functions-to-create-slide"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Pricing%20Replacement%20Function.ipynb">Step 3: Write Functions to Create Slide</a></h4>
<h5 id="example-slide--price-positioning-analysis-slide">Example slide : Price Positioning Analysis Slide</h5>
<p>![Price Positioning Analysis Slide](../Slides Documantion/price positioning slide .png)</p>
<hr>
<ul>
<li><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Pricing%20Replacement%20Function.ipynb">PricePositioning Function</a>: generates slides for a PowerPoint presentation, focusing on price positioning analysis with bubble chart visualizations. It iterates through a specified number of slides (numOfDuplicates)
<ul>
<li>parameters :
prs: PowerPoint presentation object.
modified_price_positioning_sorted: Dictionary containing sorted price positioning dataframes.
numOfDuplicates: Number of duplicate slides to generate.
position: Position index to start adding slides (default is 0).</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pricePositioning</span><span class="hljs-params">(prs,modified_price_positioning_sorted,numOfDuplicates,position=<span class="hljs-number">0</span>)</span>:</span>
    <span class="hljs-keyword">for</span> slidenum <span class="hljs-keyword">in</span> range(numOfDuplicates):
        <span class="hljs-comment"># Extract market and corresponding dataframe</span>
        market=list(modified_price_positioning_sorted.keys())[slidenum]
        df=modified_price_positioning_sorted[market].reset_index(drop=<span class="hljs-literal">True</span>)
        <span class="hljs-comment"># Access shapes in the slide</span>
        shapes = prs.slides[slidenum+position].shapes
        charts = []
        tables = []
        title = shapes.title.text
        <span class="hljs-comment"># Update text boxes in the slide</span>
        shapes[<span class="hljs-number">4</span>].text = data_source
        shapes[<span class="hljs-number">5</span>].text = <span class="hljs-string">'Brand Price &amp; Index vs Market | Bubble Size by Value Sales | '</span>+market+<span class="hljs-string">' | P12M'</span>
        shapes[<span class="hljs-number">5</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.bold = <span class="hljs-literal">True</span>

        <span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes:
            <span class="hljs-keyword">if</span> shape.has_chart:
                shape_id = shape.shape_id
                charts.append(shape)
        chart = charts[<span class="hljs-number">0</span>].chart
        charts[<span class="hljs-number">0</span>].left = Inches(<span class="hljs-number">0.57</span>) <span class="hljs-comment"># Adjust left position</span>
        chart_name = charts[<span class="hljs-number">0</span>].name
        chart_type = chart.chart_type
        <span class="hljs-comment"># Add bubble chart data</span>
        chart_data = BubbleChartData()
        chart_data.categories = df[<span class="hljs-string">'Av Price/Unit'</span>].unique().tolist()
        series = chart_data.add_series(<span class="hljs-string">"Relative Price Index"</span>)
        series.has_data_labels = <span class="hljs-literal">True</span>
  
        <span class="hljs-comment"># Add data points to the bubble chart</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(df.shape[<span class="hljs-number">0</span>]):
            series.add_data_point(df[<span class="hljs-string">'Av Price/Unit'</span>].iloc[i], df[<span class="hljs-string">'Relative Price'</span>].iloc[i], df[<span class="hljs-string">'Value Sales'</span>].iloc[i])
        chart.replace_data(chart_data)
  
        <span class="hljs-comment"># Update chart formatting</span>
        xlsx_file=BytesIO()
        <span class="hljs-keyword">with</span> chart_data._workbook_writer._open_worksheet(xlsx_file) <span class="hljs-keyword">as</span> (workbook, worksheet):
            chart_data._workbook_writer._populate_worksheet(workbook, worksheet)
            worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-string">"labels"</span>)
            worksheet.write_column(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, df[<span class="hljs-string">'Top Brands'</span>], <span class="hljs-literal">None</span>)

        chart._workbook.update_from_xlsx_blob(xlsx_file.getvalue())

        category_axis = chart.category_axis
        <span class="hljs-keyword">if</span> sign == <span class="hljs-string">'Before'</span>:
            category_axis.tick_labels.number_format = <span class="hljs-string">f'<span class="hljs-subst">{currency}</span>#,##0.00'</span>  <span class="hljs-keyword">if</span> decimals == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">f'<span class="hljs-subst">{currency}</span>#,##0'</span>
        <span class="hljs-keyword">else</span>:
            category_axis.tick_labels.number_format = <span class="hljs-string">f'#,##0.00<span class="hljs-subst">{currency}</span>'</span>  <span class="hljs-keyword">if</span> decimals == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">f'#,##0<span class="hljs-subst">{currency}</span>'</span>
    
        category_axis.auto_axis = <span class="hljs-literal">True</span>
  
        value_axis = chart.value_axis
        value_axis.tick_labels.number_format = <span class="hljs-string">'0%'</span>
        value_axis.auto_axis = <span class="hljs-literal">True</span>
  
        <span class="hljs-comment"># Customize data labels for each point in the chart</span>
        <span class="hljs-keyword">for</span> i,point <span class="hljs-keyword">in</span> enumerate(chart.series[<span class="hljs-number">0</span>].points):
            <span class="hljs-keyword">if</span> df[<span class="hljs-string">'Top Brands'</span>].iloc[i]==<span class="hljs-string">"Others"</span>:
                point.format.fill.background()
                point.data_label.text_frame.text=<span class="hljs-string">''</span>
                point.format.line.width = Pt(<span class="hljs-number">0</span>)

            <span class="hljs-keyword">else</span>:

                data_label = point.data_label
                data_label.has_text_frame=<span class="hljs-literal">True</span>
                data_label.text_frame.text=df[<span class="hljs-string">'Top Brands'</span>].iloc[i]
                data_label.text_frame.paragraphs[<span class="hljs-number">0</span>].runs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">10</span>)
                data_label.position = XL_LABEL_POSITION.CENTER
                point.format.fill.solid()
                point.format.fill.fore_color.rgb = RGBColor(<span class="hljs-number">245</span>,<span class="hljs-number">245</span>,<span class="hljs-number">245</span>)
                point.format.line.color.rgb = RGBColor(<span class="hljs-number">207</span>,<span class="hljs-number">206</span>,<span class="hljs-number">206</span>)  <span class="hljs-comment"># Set the desired RGB color value</span>
                point.format.line.width = Pt(<span class="hljs-number">1</span>)
</div></code></pre>
<hr>
<h4 id="step-4-duplicate-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Pricing%20slide%20duplicate/Pricing%20duplicate.ipynb">Step 4: Duplicate Slides</a></h4>
<ul>
<li>
<p>This code is preparing data and configurations for generating a PowerPoint presentation with multiple sections, each requiring a different number of slides based on various price and distribution analyses. It includes:</p>
<ul>
<li>Index List: Specifies the starting slide positions for different sections.</li>
<li>Duplication List: Indicates the number of slides to be generated for each section, based on the length of different datasets.</li>
<li>Section Names: Provides names for each section in the presentation.</li>
<li>Paths: Defines the file paths for the base PowerPoint template and the new duplicated presentation.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Define the index list for slide positions</span>
index = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]

<span class="hljs-comment"># Define the duplication list representing the number of slides to be generated for each section</span>
duplication = [
    len(modified_price_positioning_sorted.keys()),  <span class="hljs-comment"># Number of price positioning slides</span>
    len(modified_brands_segments_leadership.keys()),  <span class="hljs-comment"># Number of segments leadership slides</span>
    len(modified_brands_sector_leadership.keys()),  <span class="hljs-comment"># Number of sectors leadership slides</span>
    len(all_brands_sector.keys()),  <span class="hljs-comment"># Number of sector avg price/vol comparison slides</span>
    len(all_brands_sector.keys()),  <span class="hljs-comment"># Number of sector shelf price/vol comparison slides</span>
    len(all_brands_segment.keys()),  <span class="hljs-comment"># Number of segment avg price/vol comparison slides</span>
    len(all_brands_segment.keys()),  <span class="hljs-comment"># Number of segment shelf price/vol comparison slides</span>
    len(sectorP3mPD.keys()),  <span class="hljs-comment"># Number of category price point distribution analysis P3M slides</span>
    len(sectorP12mPD.keys()),  <span class="hljs-comment"># Number of category price point distribution analysis P12M slides</span>
    len(segmentP3mPD.keys()),  <span class="hljs-comment"># Number of sector price point distribution analysis P3M slides</span>
    len(segmentP12mPD.keys()),  <span class="hljs-comment"># Number of sector price point distribution analysis P12M slides</span>
    len(sub_segmentP3mPD.keys()),  <span class="hljs-comment"># Number of segment price point distribution analysis P3M slides</span>
    len(sub_segmentP12mPD.keys()),  <span class="hljs-comment"># Number of segment price point distribution analysis P12M slides</span>
    len(modified_brandPriceDistribution.keys()),  <span class="hljs-comment"># Number of price point distribution analysis by brand slides</span>
    len(modified_sectorsPriceDistribution.keys()),  <span class="hljs-comment"># Number of price point distribution by brand by sector slides</span>
    len(modified_segmentPriceDistribution.keys())  <span class="hljs-comment"># Number of price point distribution by brand by segment slides</span>
]

<span class="hljs-comment"># Define the section names to be used in the presentation</span>
section_names = [
    <span class="hljs-string">"Price Positioning Analysis"</span>,
    <span class="hljs-string">"Segments Leadership Analysis"</span>,
    <span class="hljs-string">"Sectors Leadership Analysis"</span>,
    <span class="hljs-string">"Sector Avg Price/Vol Comparison"</span>,
    <span class="hljs-string">"Sector Shelf Price/Vol Comparison"</span>,
    <span class="hljs-string">"Segment Avg Price/Vol Comparison"</span>,
    <span class="hljs-string">"Segment Shelf Price/Vol Comparison"</span>,
    <span class="hljs-string">"Category Price Point Distribution Analysis P3M"</span>,
    <span class="hljs-string">"Category Price Point Distribution Analysis P12M"</span>,
    <span class="hljs-string">"Sector Price Point Distribution Analysis P3M"</span>,
    <span class="hljs-string">"Sector Price Point Distribution Analysis P12M"</span>,
    <span class="hljs-string">"Segment Price Point Distribution Analysis P3M"</span>,
    <span class="hljs-string">"Segment Price Point Distribution Analysis P12M"</span>,
    <span class="hljs-string">"Price Point Distribution Analysis By Brand"</span>,
    <span class="hljs-string">"Price Point Distribution By Brand By Sector"</span>,
    <span class="hljs-string">"Price Point Distribution By Brand By Segment"</span>
]

<span class="hljs-comment"># Define paths for the base PowerPoint template and the new duplicated presentation</span>
path = os.getcwd() + <span class="hljs-string">'\Pricing slide base.pptx'</span>
new_pre = os.getcwd() + <span class="hljs-string">'\Pricing duplicated.pptx'</span>
</div></code></pre>
<hr>
<h4 id="step-5-replace-data-in-slide"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Pricing%20slide%20duplicate/Pricing%20duplicate.ipynb">Step 5: Replace Data in Slide</a></h4>
<ul>
<li>This part of the code calls the pricePositioning function to generate slides for the &quot;Price Positioning Analysis&quot; section of the presentation. It uses the prs PowerPoint presentation object, the dictionary modified_price_positioning_sorted containing the sorted price positioning dataframes, and the first element of the duplication list to determine the number of slides to generate. The position variable is set to 0, indicating that the slides should be added starting from the first position.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Set the initial position for slide insertion to 0</span>
position = <span class="hljs-number">0</span>

<span class="hljs-comment"># Call the pricePositioning function to generate slides for price positioning analysis</span>
pricePositioning(prs, modified_price_positioning_sorted, duplication[<span class="hljs-number">0</span>], position)

</div></code></pre>
<h4 id="step-6-save-presentation"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Pricing%20slide%20duplicate/Pricing%20duplicate.ipynb">Step 6: Save Presentation</a></h4>
<ul>
<li>This code is responsible for finalizing the creation of a PowerPoint presentation by saving it to a specified file path and then opening it using Microsoft PowerPoint. Initially, it defines the output path for the new PowerPoint presentation by combining the current working directory with the filename Pricing output.pptx. The script then saves the modified presentation (prs object) to this specified path. After saving, it uses the win32com.client.Dispatch method to create an instance of the PowerPoint application, and then it opens the saved presentation within this application. This process ensures that the newly created presentation is both saved and immediately available for viewing or further editing in Microsoft PowerPoint.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Define the output path for the new PowerPoint presentation</span>
outputPath = os.getcwd() + <span class="hljs-string">"\\Pricing output.pptx"</span>

<span class="hljs-comment"># Save the modified presentation to the specified output path</span>
prs.save(outputPath)

<span class="hljs-comment"># Open the saved PowerPoint presentation using the PowerPoint application</span>
app = win32.Dispatch(<span class="hljs-string">"PowerPoint.Application"</span>)
presentation = app.Presentations.Open(outputPath)
</div></code></pre>
<hr>
<h5 id="example-output-slide-after-replacement-data-%22pricepositioning-slide-output%22">Example: OutPut Slide After Replacement Data &quot;PricePositioning Slide OutPut&quot;</h5>
<p>![PricePositioning Slide OutPut](../Slides Documantion/price positioning slide output.png)</p>
<hr>
<h2 id="ppa-section">PPA  Section</h2>
<h3 id="introduction">Introduction</h3>
<p>In the slide automation PPA: from 5 slide base we create 4 decks
<img src="image/Slidesdocumantion/1732032681333.png" alt="1732032681333">
ColumnName= ['Size Bracket']#Run per bracket</p>
<ol>
<li>
<p>#ColumnName SLIDE 1output Slides:</p>
<ul>
<li>Brand Share Topline</li>
</ul>
</li>
<li>
<p>#ColumnName SLIDE 2-3output Slides:</p>
<ul>
<li>#ColumnName by Sector/Segment</li>
</ul>
</li>
<li>
<p>#ColumnName Slide4-5 output Slides:</p>
<ul>
<li>Brackets Analysis By Sector</li>
<li>BracketsAnalysis By Segment</li>
</ul>
</li>
<li>
<p>ISD output Slides :</p>
<ul>
<li>Inter-size
Discount Analysis</li>
</ul>
</li>
</ol>
<hr>
<h3 id="project-steps">Project Steps</h3>
<ul>
<li>Project Flow
![Project Flow](../Slides Documantion/duplication_Steps.PNG)</li>
</ul>
<ul>
<li><a href="#step-1-import-libraries">Step 1: Import Libraries we use</a></li>
<li><a href="#step-2-modified-data-frame">Step 2: modified Data frames: cleaning and preprocessing the data frames</a></li>
<li><a href="#step-3-write-functions-to-create-slide">Step 3: Write Functions to Create Slides: Define functions to dynamically generate slides based on the base slides</a></li>
<li><a href="#step-4-duplicate-slides">Step 4: Duplicate Slides: Use functions or methods to duplicate existing slides as needed for the presentation.</a></li>
<li><a href="#step-5-replace-data-in-slide">Step 5: Replace Data in Slide: update information from the cleaned data frames to slides</a></li>
<li><a href="#step-6-save-presentation">Step 6: Save Presentation</a></li>
</ul>
<hr>
<h4 id="step-1-import-libraries-we-use"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/generalFunctions.ipynb">Step 1: Import Libraries we use </a></h4>
<h5 id="ex-libraries-we-use">Ex: Libraries we use</h5>
<ul>
<li>This script sets up an environment for working with PowerPoint presentations, data manipulation, filesystem operations, and COM (Component Object Model) object access.</li>
<li>It imports necessary modules such as 'pptx' for PowerPoint automation, 'win32com' for COM object access and Windows automation, 'pandas' and 'numpy' for data manipulation,</li>
<li>'pathlib' for working with filesystem paths, 're' for regular expression operations, and various other modules for general-purpose tasks like file operations and timing functions.</li>
<li>By importing these modules, the script prepares itself for tasks such as creating or modifying PowerPoint presentations, analyzing data using pandas and numpy, interacting</li>
<li>with the Windows environment using win32com, and performing filesystem operations using shutil and os. Overall, this script provides a comprehensive setup for automating tasks</li>
<li>related to PowerPoint presentations and general-purpose Python programming.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Import necessary module for working with PowerPoint presentations</span>
<span class="hljs-keyword">from</span> pptx <span class="hljs-keyword">import</span> Presentation
<span class="hljs-comment"># Import the win32com.client module, aliasing it as win32 for convenience</span>
<span class="hljs-keyword">import</span> win32com.client <span class="hljs-keyword">as</span> win32
<span class="hljs-comment"># Import pandas for data manipulation and analysis</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># Import numpy for numerical computing</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># Import the Path class from pathlib for working with filesystem paths</span>
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-comment"># Import re for regular expression operations</span>
<span class="hljs-keyword">import</span> re
<span class="hljs-comment"># Import sys for access to interpreter-related functions</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-comment"># Import time for various time-related functions</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-comment"># Assign win32.constants to a shorter alias win32c for easier access</span>
win32c = win32.constants
<span class="hljs-comment"># Import shutil for high-level file operations</span>
<span class="hljs-keyword">import</span> shutil
<span class="hljs-comment"># Import os for operating system dependent functionality</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-comment"># Import win32com.client again for COM object and functions access</span>
<span class="hljs-keyword">import</span> win32com.client
<span class="hljs-comment"># Import warnings for warning control functionality</span>
<span class="hljs-keyword">import</span> warnings
</div></code></pre>
<hr>
<h4 id="step-2-modified-data-frame"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/PPA%20slide%20duplicate/PPA%20Duplicate.ipynb">Step 2: modified Data frame</a></h4>
<h5 id="ex-input-dataframes-before-cleaning">EX: input dataframes before cleaning</h5>
<p>![PPA data frame before Cleaning ](../Slides Documantion/PPA input data frame .png)</p>
<hr>
<h5 id="cleaning-data-frame">Cleaning Data Frame</h5>
<ul>
<li>This code is part of a data processing pipeline for cleaning and preparing bracket-related data. It selects the appropriate DataFrame based on columnName, processes elements in a brackets list, and iterates over ppaDf keys to rename columns, remove rows, forward-fill missing values, replace NaNs, and sort by 'Value Share'. Cleaned DataFrames are stored in ToplineBracket. The script methodically handles data preparation, crucial for accurate analysis and reporting, but the use of brackets and commented-out lines suggest the code may still be in development or require additional context.</li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-comment"># Assign the appropriate DataFrame based on the value of columnName</span>
ppaDf = share_topline_base_price_bracket <span class="hljs-keyword">if</span> columnName == <span class="hljs-string">"Base Price Bracket"</span> <span class="hljs-keyword">else</span> share_topline_size_bracket

<span class="hljs-comment"># The variable 'brackets' is used but not defined in this snippet; it should be defined beforehand.</span>

<span class="hljs-comment"># Iterate over the elements in 'brackets'</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> brackets:
    <span class="hljs-comment"># Create a formatted string based on the elements of 'brackets', replacing special characters and converting to lowercase</span>
    <span class="hljs-string">f"share_topline_<span class="hljs-subst">{i.split(<span class="hljs-string">'.['</span>)[<span class="hljs-number">1</span>]}</span>"</span>.replace(<span class="hljs-string">"]"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">" "</span>,<span class="hljs-string">"_"</span>).lower()

<span class="hljs-comment"># Initialize dictionaries to store processed DataFrames</span>
ToplineBracket = {}
ToplineBracketTotal = {}

<span class="hljs-comment"># Iterate over the keys in ppaDf</span>
<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> ppaDf.keys():
    df = ppaDf[key].copy()  <span class="hljs-comment"># Create a copy of the DataFrame to avoid modifying the original</span>
    df.columns = df.iloc[<span class="hljs-number">12</span>].str.replace(<span class="hljs-string">'\xa0'</span>,<span class="hljs-string">' '</span>)  <span class="hljs-comment"># Rename columns by replacing non-breaking spaces with regular spaces</span>
    df = df.iloc[<span class="hljs-number">13</span>:<span class="hljs-number">-1</span>]  <span class="hljs-comment"># Remove the first 13 rows and the last row</span>
    df[columnName] = df[columnName].ffill()  <span class="hljs-comment"># Forward-fill missing values in the specified column</span>
    <span class="hljs-comment"># df_tot = df[df['Size Bracket'].str.contains("Total")]  # (Optional) Filter rows that contain "Total" in 'Size Bracket'</span>
    <span class="hljs-comment"># df_brands = df[~df["Size Bracket"].isin(df_tot['Size Bracket'])]  # (Optional) Exclude rows that match 'df_tot'</span>
    df[[<span class="hljs-string">"Value Share"</span>, <span class="hljs-string">"Brand WoB %"</span>, <span class="hljs-string">"Value Sales IYA"</span>, <span class="hljs-string">"Relative Price"</span>]] = df[[<span class="hljs-string">"Value Share"</span>, <span class="hljs-string">"Brand WoB %"</span>, <span class="hljs-string">"Value Sales IYA"</span>, <span class="hljs-string">"Relative Price"</span>]].replace(np.nan, <span class="hljs-number">0</span>).astype(float)  <span class="hljs-comment"># Replace NaN values with 0 and convert to float</span>
    df = df.sort_values(<span class="hljs-string">'Value Share'</span>, ascending=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># Sort the DataFrame by 'Value Share' in descending order</span>
  
    <span class="hljs-comment"># Check if the DataFrame is empty and print the key if it is</span>
    <span class="hljs-keyword">if</span> df.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:
        print(key)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># ToplineBracketTotal[key] = df_tot  # (Optional) Store the 'Total' filtered DataFrame</span>
        ToplineBracket[key] = df  <span class="hljs-comment"># Store the processed DataFrame in the dictionary</span>

<span class="hljs-comment"># Extract unique values from the processed DataFrames, removing ' Total' and collecting them into a list</span>
bracketsValue = list(set([value.replace(<span class="hljs-string">' Total'</span>,<span class="hljs-string">''</span>) <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> ToplineBracket.values() <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> val[columnName].unique() <span class="hljs-keyword">if</span> <span class="hljs-string">'Total'</span> <span class="hljs-keyword">in</span> value]))
  
</div></code></pre>
<hr>
<h5 id="data-frame-after-cleaning">Data Frame After cleaning</h5>
<p>![Data Frame After cleaning](../Slides Documantion/PPA output dataframe.png)</p>
<hr>
<h4 id="step-3-write-functions-to-create-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/PPA%20Replacement%20Function.ipynb">Step 3: Write Functions to Create Slides</a></h4>
<h5 id="example-slide--brand-share-topline-by-size-bracket">Example slide : Brand Share Topline By Size Bracket</h5>
<p>![Brand Share Topline By Size Bracket](../Slides Documantion/PPA base slide .png)</p>
<hr>
<ul>
<li><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/PPA%20Replacement%20Function.ipynb">brandShareToplin</a>function:Generate a PowerPoint slide presentation with data visualizations and tables showing brand share topline metrics by various brackets for a specified number of slides.
<ul>
<li>Parameters:
prs (pptx.presentation.Presentation): The PowerPoint presentation object where slides will be added or modified.
modifiedShareToplineBracket (dict): Dictionary containing data frames for different markets.
bracketsValue (list): List of size brackets to be considered.
clientElement (str): Name of the client brand to highlight in the presentation.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brandShareTopline</span><span class="hljs-params">(prs, modifiedShareToplineBracket, bracketsValue, numOfDuplicates, slide_by, clientElement, position=<span class="hljs-number">0</span>)</span>:</span>  
    <span class="hljs-keyword">for</span> slidenum <span class="hljs-keyword">in</span> range(numOfDuplicates):
        <span class="hljs-comment"># Get the market name and its corresponding data frame</span>
        market = list(modifiedShareToplineBracket.keys())[slidenum]
        df = modifiedShareToplineBracket[market].copy()
        <span class="hljs-comment"># Extract and sort 'Size' from the slide_by column</span>
        df[<span class="hljs-string">'Size'</span>] = df[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].apply(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> <span class="hljs-string">'-'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> <span class="hljs-number">9999</span>).astype(float)
        df = df.sort_values(by=[<span class="hljs-string">'Size'</span>], ascending=<span class="hljs-literal">False</span>)  
        <span class="hljs-comment"># Filter total brand data and clean up column values</span>
        dfTotalBrand = df[df[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].str.contains(<span class="hljs-string">'Total'</span>)]
        dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>] = dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].str.replace(<span class="hljs-string">' Total'</span>, <span class="hljs-string">''</span>)
        dfTotalBrand = dfTotalBrand[dfTotalBrand[<span class="hljs-string">'Value Share'</span>] &gt; <span class="hljs-number">.01</span>]
  
        <span class="hljs-comment"># Filter the main data frame based on size</span>
        df = df[df[<span class="hljs-string">'Size'</span>].isin(dfTotalBrand[<span class="hljs-string">'Size'</span>].unique())].sort_values(by=<span class="hljs-string">'Value Share'</span>, ascending=<span class="hljs-literal">False</span>)
  
        <span class="hljs-comment"># Get the top 3 brands excluding the client element</span>
        dfTopSales = df[(df[<span class="hljs-string">'Top Brands'</span>].notna()) &amp; (df[<span class="hljs-string">'Top Brands'</span>] != clientElement)].drop_duplicates(subset=<span class="hljs-string">'Top Brands'</span>)[<span class="hljs-string">'Top Brands'</span>].iloc[:<span class="hljs-number">3</span>].to_list()
        dfBrandInScope = df[df[<span class="hljs-string">'Top Brands'</span>].isin(dfTopSales)]
  
        <span class="hljs-comment"># Calculate the 'Other' category for the data frame</span>
        dfOther = df[(~df[<span class="hljs-string">'Top Brands'</span>].isin(dfTopSales + [clientElement])) &amp; (~df[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].str.contains(<span class="hljs-string">'Total'</span>))].groupby([<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>, <span class="hljs-string">'Size'</span>])[<span class="hljs-string">'Value Share'</span>].sum().reset_index().sort_values(by=<span class="hljs-string">'Size'</span>, ascending=<span class="hljs-literal">False</span>)
        missingOtherBracket = list(set(bracketsValue) - set(dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()))
        missingOtherBracket = pd.DataFrame({<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>: missingOtherBracket, <span class="hljs-string">'Size'</span>: [float(x.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> <span class="hljs-string">'-'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> <span class="hljs-number">9999</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> missingOtherBracket]})
        dfOther = pd.concat([dfOther, missingOtherBracket]).sort_values(by=<span class="hljs-string">'Size'</span>, ascending=<span class="hljs-literal">False</span>)
        dfTotalBrand = pd.concat([dfTotalBrand, missingOtherBracket]).sort_values(by=<span class="hljs-string">'Size'</span>, ascending=<span class="hljs-literal">False</span>)
  
        <span class="hljs-comment"># Filter the client's brand data</span>
        dfClientBrand = df[df[<span class="hljs-string">'Top Brands'</span>] == clientElement]
  
        <span class="hljs-comment"># Access slide shapes to update text and formatting</span>
        shapes = prs.slides[slidenum + position].shapes
        shapes[<span class="hljs-number">4</span>].text = data_source
        shapes[<span class="hljs-number">5</span>].text = <span class="hljs-string">f'Brand Share Topline By <span class="hljs-subst">{slide_by}</span> | <span class="hljs-subst">{market}</span> | P12M'</span>
        <span class="hljs-comment"># Format text as bold and set font size</span>
        shapes[<span class="hljs-number">5</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.bold = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(len(shapes[<span class="hljs-number">5</span>].text_frame.paragraphs)):
            shapes[<span class="hljs-number">5</span>].text_frame.paragraphs[p].font.size = Pt(<span class="hljs-number">12</span>)
        shapes[<span class="hljs-number">6</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].runs[<span class="hljs-number">0</span>].text = shapes[<span class="hljs-number">6</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].runs[<span class="hljs-number">0</span>].text.replace(<span class="hljs-string">'Size Bracket'</span>, slide_by)
        shapes[<span class="hljs-number">6</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">16</span>)
        <span class="hljs-comment"># Create tables and charts</span>
        tables, charts = createTableAndChart(shapes)
        <span class="hljs-comment"># Adjust table row numbers</span>
        table = tables[<span class="hljs-number">0</span>].table
        num_rows_to_remove = len(table.rows) - dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].nunique() - <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(num_rows_to_remove):
            <span class="hljs-keyword">if</span> len(table.rows) &gt; <span class="hljs-number">1</span>:  <span class="hljs-comment"># Skip removing the first row if there is more than one row</span>
                row = table.rows[<span class="hljs-number">1</span>]
                remove_row(table, row)
        <span class="hljs-comment"># Set table row height</span>
        table_height = Inches(<span class="hljs-number">3.81</span>)  <span class="hljs-comment"># Specify the desired table height</span>
        total_row_height = table_height - table.rows[<span class="hljs-number">0</span>].height
        num_rows = len(table.rows) - <span class="hljs-number">1</span>  <span class="hljs-comment"># Exclude the first row</span>
        <span class="hljs-keyword">if</span> num_rows &gt; <span class="hljs-number">0</span>:
            cell_height = total_row_height / num_rows
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(table.rows)):
                table.rows[row].height = int(cell_height)
  
        <span class="hljs-comment"># Replace the table data</span>
        <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> enumerate(table.rows):
            <span class="hljs-keyword">for</span> j, cell <span class="hljs-keyword">in</span> enumerate(row.cells):
                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:
                    <span class="hljs-comment"># Update header cells</span>
                    <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]:
                        cell.text = cell.text.replace(<span class="hljs-string">'Brand'</span>, clientElement)
                        <span class="hljs-keyword">for</span> paragraph <span class="hljs-keyword">in</span> cell.text_frame.paragraphs:
                            paragraph.font.name = <span class="hljs-string">'Nexa Bold'</span>
                            paragraph.font.size = Pt(<span class="hljs-number">9</span>)
                            paragraph.alignment = PP_ALIGN.CENTER
                            paragraph.font.color.rgb = RGBColor(<span class="hljs-number">87</span>, <span class="hljs-number">85</span>, <span class="hljs-number">85</span>)
                            paragraph.font.bold = <span class="hljs-literal">False</span>
                    <span class="hljs-keyword">continue</span>
                <span class="hljs-comment"># Update data cells</span>
                sizeBracket = dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()[i - <span class="hljs-number">1</span>]
                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:
                    cell.text = sizeBracket
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Bold'</span>
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">9</span>)
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].alignment = PP_ALIGN.CENTER
                <span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">4</span>:
                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span>:
                        value = dfClientBrand[dfClientBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>] == sizeBracket][<span class="hljs-string">'Value Sales IYA'</span>].unique()
                        <span class="hljs-comment"># Exclude Brand 'Brand WoB %' &lt; 5%</span>
                        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">and</span> dfClientBrand[dfClientBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>] == sizeBracket][<span class="hljs-string">'Brand WoB %'</span>].unique()[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">.0005</span>:
                            value = [<span class="hljs-number">0</span>]
                        cell.text = <span class="hljs-string">''</span> <span class="hljs-keyword">if</span> (len(value) == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (int(round(float(value[<span class="hljs-number">0</span>]) * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> (str(int(round(float(value[<span class="hljs-number">0</span>]) * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>))) + <span class="hljs-string">'%'</span> <span class="hljs-keyword">if</span> int(round(float(value[<span class="hljs-number">0</span>]) * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">1000</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'Large'</span>)
                    <span class="hljs-keyword">else</span>:
                        value = dfClientBrand[dfClientBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>] == sizeBracket][<span class="hljs-string">'Relative Price'</span>].unique()
                        <span class="hljs-comment"># Exclude Brand 'Brand WoB %' &lt; 5%</span>
                        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">and</span> dfClientBrand[dfClientBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>] == sizeBracket][<span class="hljs-string">'Brand WoB %'</span>].unique()[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">.0005</span>:
                            value = [<span class="hljs-number">0</span>]
                        cell.text = <span class="hljs-string">''</span> <span class="hljs-keyword">if</span> len(value) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> (int(round(float(value[<span class="hljs-number">0</span>]) * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> str(int(round(float(value[<span class="hljs-number">0</span>]) * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>))) + <span class="hljs-string">'%'</span>
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Book'</span>
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">8</span>)
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].alignment = PP_ALIGN.CENTER
        <span class="hljs-comment"># Update chart data</span>
        <span class="hljs-keyword">for</span> chartNum <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]:
            chart = charts[chartNum].chart
            chart_data = CategoryChartData()
            chart_data.categories = [<span class="hljs-string">''</span>]
            <span class="hljs-keyword">if</span> chartNum == <span class="hljs-number">0</span>:
                missingBrandBracket = list(set(dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()) - set(dfClientBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()))
                missingBrandBracket = pd.DataFrame({<span class="hljs-string">'Top Brands'</span>: clientElement, <span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>: missingBrandBracket, <span class="hljs-string">'Size'</span>: [float(x.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> <span class="hljs-string">'-'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> <span class="hljs-number">9999</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> missingBrandBracket]})
                dfClientBrand2 = pd.concat([dfClientBrand, missingBrandBracket]).sort_values(by=<span class="hljs-string">'Size'</span>, ascending=<span class="hljs-literal">False</span>).replace(np.nan, <span class="hljs-literal">None</span>)
                <span class="hljs-comment"># Exclude Value Share less than 5%</span>
                dfClientBrand2[<span class="hljs-string">'Brand WoB %'</span>] = np.where(dfClientBrand2[<span class="hljs-string">'Brand WoB %'</span>] &lt; <span class="hljs-number">.0005</span>, <span class="hljs-literal">None</span>, dfClientBrand2[<span class="hljs-string">'Brand WoB %'</span>])
                brandWob = dfClientBrand2[<span class="hljs-string">'Brand WoB %'</span>].to_list()
                chart_data.add_series(<span class="hljs-string">'Brand WoB %'</span>, brandWob)
            <span class="hljs-keyword">else</span>:
                valueShare = dfTotalBrand[<span class="hljs-string">'Value Share'</span>].replace(np.nan, <span class="hljs-literal">None</span>).to_list()
                chart_data.add_series(<span class="hljs-string">'Value Share'</span>, valueShare)
            chart.replace_data(chart_data)
        <span class="hljs-comment"># Update the comparison chart</span>
        chart2 = charts[<span class="hljs-number">2</span>].chart
        chart_data2 = CategoryChartData()
        chart_data2.categories = dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()
        missingBrandBracket = list(set(dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()) - set(dfClientBrand[dfClientBrand[<span class="hljs-string">'Top Brands'</span>] == clientElement][<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()))
        missingBrandBracket = pd.DataFrame({<span class="hljs-string">'Top Brands'</span>: clientElement, <span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>: missingBrandBracket, <span class="hljs-string">'Size'</span>: [float(x.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> <span class="hljs-string">'-'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> <span class="hljs-number">9999</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> missingBrandBracket]})
        dfClientBrand2 = pd.concat([dfClientBrand[dfClientBrand[<span class="hljs-string">'Top Brands'</span>] == clientElement], missingBrandBracket]).sort_values(by=<span class="hljs-string">'Size'</span>, ascending=<span class="hljs-literal">False</span>)
        valueShare = dfClientBrand2[<span class="hljs-string">'Value Share'</span>].replace(np.nan, <span class="hljs-literal">None</span>).to_list()
        chart_data2.add_series(clientElement, valueShare)
        <span class="hljs-keyword">for</span> brand <span class="hljs-keyword">in</span> dfBrandInScope[<span class="hljs-string">'Top Brands'</span>].unique():
            missingBrandBracket = list(set(dfTotalBrand[<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()) - set(dfBrandInScope[dfBrandInScope[<span class="hljs-string">'Top Brands'</span>] == brand][<span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>].unique()))
            missingBrandBracket = pd.DataFrame({<span class="hljs-string">'Top Brands'</span>: brand, <span class="hljs-string">f"<span class="hljs-subst">{slide_by}</span>"</span>: missingBrandBracket, <span class="hljs-string">'Size'</span>: [float(x.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> <span class="hljs-string">'-'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> <span class="hljs-number">9999</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> missingBrandBracket]})
            dfClientBrand2 = pd.concat([dfBrandInScope[dfBrandInScope[<span class="hljs-string">'Top Brands'</span>] == brand], missingBrandBracket]).sort_values(by=<span class="hljs-string">'Size'</span>, ascending=<span class="hljs-literal">False</span>)
            valueShare = dfClientBrand2[<span class="hljs-string">'Value Share'</span>].replace(np.nan, <span class="hljs-literal">None</span>).to_list()
            chart_data2.add_series(brand, valueShare)
        valueShare = dfOther[<span class="hljs-string">'Value Share'</span>].replace(np.nan, <span class="hljs-literal">None</span>).to_list()
        chart_data2.add_series(<span class="hljs-string">'Others'</span>, valueShare)
  
        chart2.replace_data(chart_data2)
</div></code></pre>
<hr>
<h4 id="step-4-duplicate-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/PPA%20slide%20duplicate/PPA%20Duplicate.ipynb">Step 4: Duplicate Slides</a></h4>
<p>[Duplicate Slides](../PPA slide duplicate/PPA Duplicate.ipynb): this part of code calculate duplication values, and define section names for generating or updating a PowerPoint presentation.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Generate a list of indices based on various category, sector, segment, and channel indices</span>
index = [<span class="hljs-number">0</span>, *categoryIndex, *sectorIndex, *segmentIndex, *channelRepeat]

<span class="hljs-comment"># Calculate the number of duplications for each section</span>
duplication = [
    len(ToplineBracket.keys()) * len(clientBrand),  <span class="hljs-comment"># Duplication for the main topline section</span>
    *[len(dfLis) * len(clientBrand)] * (<span class="hljs-number">3</span> <span class="hljs-keyword">if</span> len(segmentInScope) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>),  <span class="hljs-comment"># Duplication for sector/segment</span>
    len(categories) * len(clientBrand),  <span class="hljs-comment"># Duplication for categories</span>
    len(sectorInScope) * len(clientBrand),  <span class="hljs-comment"># Duplication for sectors</span>
    len(segmentInScope) * len(clientBrand)  <span class="hljs-comment"># Duplication for segments</span>
]

<span class="hljs-comment"># Remove any zero duplication values from the list</span>
duplication = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> duplication <span class="hljs-keyword">if</span> item != <span class="hljs-number">0</span>]

<span class="hljs-comment"># Define section names for the slides</span>
section_names_slide1 = [<span class="hljs-string">"Brand Share Topline By "</span> + columnName]
section_names_slide2 = [
    columnName + <span class="hljs-string">" By Sector/Segment By Category"</span>,
    columnName + <span class="hljs-string">" By Sector/Segment By Sector"</span>
] + ([columnName + <span class="hljs-string">" By Sector/Segment By Segment"</span>] <span class="hljs-keyword">if</span> len(segmentInScope) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [])

section_names_slide3 = [
    columnName + <span class="hljs-string">" By Channel/Retailer By Category"</span>,
    columnName + <span class="hljs-string">" By Channel/Retailer By Sector"</span>
] + ([columnName + <span class="hljs-string">" By Channel/Retailer By Segment"</span>] <span class="hljs-keyword">if</span> len(segmentInScope) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [])

<span class="hljs-comment"># Combine all section names into one list</span>
section_names = [*section_names_slide1, *section_names_slide2, *section_names_slide3]

<span class="hljs-comment"># Define the path to the base PowerPoint slide and the new duplicated slide</span>
path = os.getcwd() + <span class="hljs-string">'\\PPA slide base.pptx'</span>
new_pre = os.getcwd() + <span class="hljs-string">'\\PPA slide duplicate.pptx'</span>
</div></code></pre>
<hr>
<h4 id="step-5-replace-data-in-slide"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/PPA%20slide%20duplicate/PPA%20Duplicate.ipynb">Step 5: Replace Data in Slide</a></h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Initialize the starting position for slides</span>
position = <span class="hljs-number">0</span>

<span class="hljs-comment"># Determine the number of duplicates for the current section</span>
numOfDuplicates = duplication[sectionPosition]

<span class="hljs-comment"># Iterate over each client brand</span>
<span class="hljs-keyword">for</span> i, clientElement <span class="hljs-keyword">in</span> enumerate(clientBrand):
    <span class="hljs-comment"># Call the brandShareTopline function to generate slides for each client brand</span>
    <span class="hljs-comment"># Parameters:</span>
    <span class="hljs-comment"># - prs: The PowerPoint presentation object</span>
    <span class="hljs-comment"># - ToplineBracket: Dictionary containing data frames for different markets</span>
    <span class="hljs-comment"># - bracketsValue: List of size brackets to be considered</span>
    <span class="hljs-comment"># - numOfDuplicates/len(clientBrand): Number of slides to create or modify for each brand</span>
    <span class="hljs-comment"># - slide_by: Column name used to determine the bracket type (specified by columnName)</span>
    <span class="hljs-comment"># - clientElement: Name of the client brand to highlight in the presentation</span>
    <span class="hljs-comment"># - position: Position offset for the slides (updated in each iteration)</span>
    brandShareTopline(prs, ToplineBracket, bracketsValue, int(numOfDuplicates / len(clientBrand)), slide_by=columnName, clientElement=clientElement, position=position)
  
    <span class="hljs-comment"># Update the position for the next set of slides</span>
    <span class="hljs-comment"># Dividing numOfDuplicates by 3 to spread out the positions evenly</span>
    position = int(position + numOfDuplicates / <span class="hljs-number">3</span>)

<span class="hljs-comment"># Move to the next section position</span>
sectionPosition += <span class="hljs-number">1</span>
</div></code></pre>
<h4 id="step-6-save-presentation"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/PPA%20slide%20duplicate/PPA%20Duplicate.ipynb">Step 6: Save Presentation</a></h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Define the path for saving the output presentation</span>
<span class="hljs-comment"># This combines the current working directory with the column name and "output.pptx"</span>
outputPath = os.getcwd() + <span class="hljs-string">'\\'</span> + columnName + <span class="hljs-string">" output.pptx"</span>

<span class="hljs-comment"># Save the PowerPoint presentation to the specified output path</span>
prs.save(outputPath)

<span class="hljs-comment"># Use the win32 library to open the saved PowerPoint presentation</span>
<span class="hljs-comment"># This dispatches the PowerPoint application and opens the presentation</span>
app = win32.Dispatch(<span class="hljs-string">"PowerPoint.Application"</span>)
presentation = app.Presentations.Open(outputPath)
</div></code></pre>
<hr>
<h5 id="example-output-slide-after-replacement-data-%22brand-share-topline-by-size-bracket-slide-output%22">Example: OutPut Slide After Replacement Data &quot;Brand Share Topline By Size Bracket Slide OutPut&quot;</h5>
<p>![Brand Share Topline By Size Bracket](../Slides Documantion/PPA output slide .png)</p>
<hr>
<h2 id="mixassortment-section">Mix&amp;Assortment Section</h2>
<h3 id="introduction">Introduction</h3>
<p>In slide automation Mix&amp;Assortment Section using 7 basic slides we have created 7 sections</p>
<ul>
<li>SKU Share By Brand</li>
<li>Cumulative Product Shares</li>
<li>Top 50% cumulative share</li>
<li>Brand Cumulative Product Share</li>
<li>Top 20 cumulative share</li>
<li>SKU Productivity Analysis with TM%</li>
<li>SKU Productivity Analysis with WD</li>
</ul>
<hr>
<h3 id="project-steps">Project Steps</h3>
<ul>
<li>Project Flow
![Project Flow](../Slides Documantion/duplication_Steps.PNG)</li>
</ul>
<ul>
<li><a href="#step-1-import-libraries">Step 1: Import Libraries we use</a></li>
<li><a href="#step-2-modified-data-frame">Step 2: modified Data frames: cleaning and preprocessing the data frames</a></li>
<li><a href="#step-3-write-functions-to-create-slide">Step 3: Write Functions to Create Slides: Define functions to dynamically generate slides based on the base slides</a></li>
<li><a href="#step-4-duplicate-slides">Step 4: Duplicate Slides: Use functions or methods to duplicate existing slides as needed for the presentation.</a></li>
<li><a href="#step-5-replace-data-in-slide">Step 5: Replace Data in Slide: update information from the cleaned data frames to slides</a></li>
<li><a href="#step-6-save-presentation">Step 6: Save Presentation</a></li>
</ul>
<hr>
<h4 id="step-1-import-libraries-we-use"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/generalFunctions.ipynb">Step 1: Import Libraries we use </a></h4>
<h5 id="ex-libraries-we-use">Ex: Libraries we use</h5>
<ul>
<li>This script sets up an environment for working with PowerPoint presentations, data manipulation, filesystem operations, and COM (Component Object Model) object access.</li>
<li>It imports necessary modules such as 'pptx' for PowerPoint automation, 'win32com' for COM object access and Windows automation, 'pandas' and 'numpy' for data manipulation,</li>
<li>'pathlib' for working with filesystem paths, 're' for regular expression operations, and various other modules for general-purpose tasks like file operations and timing functions.</li>
<li>By importing these modules, the script prepares itself for tasks such as creating or modifying PowerPoint presentations, analyzing data using pandas and numpy, interacting</li>
<li>with the Windows environment using win32com, and performing filesystem operations using shutil and os. Overall, this script provides a comprehensive setup for automating tasks</li>
<li>related to PowerPoint presentations and general-purpose Python programming.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Import necessary module for working with PowerPoint presentations</span>
<span class="hljs-keyword">from</span> pptx <span class="hljs-keyword">import</span> Presentation
<span class="hljs-comment"># Import the win32com.client module, aliasing it as win32 for convenience</span>
<span class="hljs-keyword">import</span> win32com.client <span class="hljs-keyword">as</span> win32
<span class="hljs-comment"># Import pandas for data manipulation and analysis</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># Import numpy for numerical computing</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># Import the Path class from pathlib for working with filesystem paths</span>
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-comment"># Import re for regular expression operations</span>
<span class="hljs-keyword">import</span> re
<span class="hljs-comment"># Import sys for access to interpreter-related functions</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-comment"># Import time for various time-related functions</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-comment"># Assign win32.constants to a shorter alias win32c for easier access</span>
win32c = win32.constants
<span class="hljs-comment"># Import shutil for high-level file operations</span>
<span class="hljs-keyword">import</span> shutil
<span class="hljs-comment"># Import os for operating system dependent functionality</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-comment"># Import win32com.client again for COM object and functions access</span>
<span class="hljs-keyword">import</span> win32com.client
<span class="hljs-comment"># Import warnings for warning control functionality</span>
<span class="hljs-keyword">import</span> warnings
</div></code></pre>
<hr>
<h4 id="step-2-modified-data-frames"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Assortment%20Slide%20Duplicate/Assortment%20Duplicate.ipynb">Step 2: modified Data frames</a></h4>
<h5 id="ex-input-dataframes-before-cleaning">EX: input dataframes before cleaning</h5>
<p>![assortment input dataframe before cleaning](../Slides Documantion/assortment dataframe before cleaning .png)</p>
<hr>
<h5 id="cleaning-code">cleaning Code</h5>
<ul>
<li><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Assortment%20Slide%20Duplicate/Assortment%20Duplicate.ipynb">mixAssortmentCleaning function</a>: Cleans and processes assortment and cumulative share data to provide modified data for brand-specific analysis.
<ul>
<li>Args:
assortment (dict): Dictionary containing assortment data.
cumulativeShare (dict): Dictionary containing cumulative share data.</li>
<li>Returns:
tuple:
<ul>
<li>assortmentModifiedBrand (dict): Dictionary containing cleaned and modified assortment data for brands.</li>
<li>assortmentModifiedTotal (dict): Dictionary containing cleaned and modified total assortment data.</li>
<li>assortmentClient (dict): Dictionary containing client-specific cleaned and modified assortment data.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mixAssortmentCleaning</span><span class="hljs-params">(assortment, cumulativeShare)</span>:</span>
    <span class="hljs-comment"># Initialize dictionaries to store modified data</span>
    cumulativeShareModifiedBrand = {}
    assortmentModified = {}
    assortmentModifiedBrand = {}
    assortmentModifiedTotal = {}
    assortmentClient = {}
    <span class="hljs-comment"># Process cumulative share data</span>
    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cumulativeShare.items():
        dfcumulative = value.iloc[<span class="hljs-number">11</span>:].reset_index(drop=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># Adjust the dataframe to remove unnecessary rows</span>
        dfcumulative.columns = dfcumulative.iloc[<span class="hljs-number">0</span>]  <span class="hljs-comment"># Set the first row as the column headers</span>
        dfcumulative = dfcumulative.iloc[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># Remove the row used for headers</span>
        <span class="hljs-keyword">if</span> dfcumulative.shape[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>:  <span class="hljs-comment"># If the dataframe is not empty</span>
            newKey = key
            <span class="hljs-keyword">if</span> key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> categories:  <span class="hljs-comment"># Adjust key if it does not match category format</span>
                newKey = key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">' | '</span> + key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>]
            cumulativeShareModifiedBrand[newKey] = dfcumulative.replace(np.nan, <span class="hljs-number">0</span>)  <span class="hljs-comment"># </span>
    <span class="hljs-comment"># Process assortment data</span>
    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> assortment.items():
        df = value.iloc[<span class="hljs-number">12</span>:].reset_index(drop=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># Adjust the dataframe to remove unnecessary rows</span>
        df.columns = df.iloc[<span class="hljs-number">0</span>]  <span class="hljs-comment"># Set the first row as the column headers</span>
        df = df.iloc[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># Remove the row used for headers</span>
        df[<span class="hljs-string">'Top Brands'</span>] = df[<span class="hljs-string">'Top Brands'</span>].ffill()  <span class="hljs-comment"># Forward fill 'Top Brands' colum</span>
        <span class="hljs-comment"># Replace specific values in 'Top Brands' as per 'valueToReplace' dictionary</span>
        <span class="hljs-keyword">for</span> val, replacer <span class="hljs-keyword">in</span> valueToReplace.items():
            df[<span class="hljs-string">'Top Brands'</span>] = df[<span class="hljs-string">'Top Brands'</span>].str.replace(val, replacer)
        dfBrand = df[~df[<span class="hljs-string">'Top Brands'</span>].str.contains(<span class="hljs-string">'Total'</span>)]  <span class="hljs-comment"># Filter out rows containing 'Total' in 'Top Brands'</span>
        dfTotal = df[df[<span class="hljs-string">'Top Brands'</span>].str.contains(<span class="hljs-string">'Total'</span>) &amp; (df[<span class="hljs-string">'Top Brands'</span>] != <span class="hljs-string">'Grand Total'</span>)].reset_index(drop=<span class="hljs-literal">True</span>)
        dfTotal[<span class="hljs-string">'Top Brands'</span>] = dfTotal[<span class="hljs-string">'Top Brands'</span>].str.replace(<span class="hljs-string">' Total'</span>, <span class="hljs-string">''</span>)  <span class="hljs-comment"># Adjust 'Top Brands' column for total rows</span>
        <span class="hljs-keyword">if</span> df.shape[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>:  <span class="hljs-comment"># If the dataframe is not empty</span>
            newKey = key
            <span class="hljs-keyword">if</span> key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> categories:  <span class="hljs-comment"># Adjust key if it does not match category format</span>
                newKey = key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">' | '</span> + key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>]
            <span class="hljs-comment"># Process client-specific data for each brand</span>
            <span class="hljs-keyword">for</span> brand <span class="hljs-keyword">in</span> client_brands_competitor:
                <span class="hljs-keyword">if</span> df[df[<span class="hljs-string">'Top Brands'</span>] == brand].shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># Check if brand data exists in dataframe</span>
                    assortmentClient[newKey + <span class="hljs-string">' | '</span> + brand] = df[df[<span class="hljs-string">'Top Brands'</span>] == brand].replace(np.nan, <span class="hljs-number">0</span>)
                    assortmentClient[newKey + <span class="hljs-string">' | '</span> + brand] = assortmentClient[newKey + <span class="hljs-string">' | '</span> + brand].merge(
                        cumulativeShareModifiedBrand[newKey], how=<span class="hljs-string">'left'</span>, on=<span class="hljs-string">'Product'</span>)
            <span class="hljs-comment"># Store modified data for total, brand, and overall assortment</span>
            assortmentModified[newKey] = df.replace(np.nan, <span class="hljs-number">0</span>)
            assortmentModifiedBrand[newKey] = dfBrand.replace(np.nan, <span class="hljs-number">0</span>).drop(columns=[<span class="hljs-string">'Cumulative Product Share'</span>])
            assortmentModifiedBrand[newKey] = assortmentModifiedBrand[newKey].merge(
                cumulativeShareModifiedBrand[newKey], how=<span class="hljs-string">'left'</span>, on=<span class="hljs-string">'Product'</span>)
            assortmentModifiedTotal[newKey] = dfTotal.replace(np.nan, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> assortmentModifiedBrand, assortmentModifiedTotal, assortmentClient
</div></code></pre>
<hr>
<h5 id="calling-function--data-frame-after-cleaning">Calling function &amp; data frame After cleaning</h5>
<p>![Calling function &amp; data frame After  cleaning](../Slides Documantion/assortment calling function &amp;dataframe after clean.png)</p>
<hr>
<h4 id="step-3-write-functions-to-create-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Assortment%20Replacement%20Function.ipynb">Step 3: Write Functions to Create Slides</a></h4>
<h5 id="example-slide--sku-share-by-brand">Example Slide : SKU Share By Brand</h5>
<p>![SKU Share By Brand](../Slides Documantion/assortment base slide .png)</p>
<hr>
<h5 id="replacement-function">Replacement function</h5>
<ul>
<li><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Assortment%20Replacement%20Function.ipynb">SkuShareByBrand function</a>:Updates PowerPoint slides with SKU and Value Share data by brand for a given market.
<ul>
<li>Args:
prs (Presentation): The PowerPoint presentation object.
assortmentTotalSorted (dict): Dictionary containing sorted assortment data by market.
numOfDuplicates (int): Number of slides to duplicate and update.
position (int, optional): Starting position for slide updates. Default is 0.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SkuShareByBrand</span><span class="hljs-params">(prs, assortmentTotalSorted, numOfDuplicates, position=<span class="hljs-number">0</span>)</span>:</span>
    <span class="hljs-keyword">for</span> slidenum <span class="hljs-keyword">in</span> range(numOfDuplicates):
        market = list(assortmentTotalSorted.keys())[slidenum]
        df = assortmentTotalSorted[market].copy()
  
        <span class="hljs-comment"># Sort the dataframe by 'Value Share' in descending order</span>
        df = df.sort_values(<span class="hljs-string">'Value Share'</span>, ascending=<span class="hljs-literal">False</span>)
  
        <span class="hljs-comment"># Ensure that 'Others' is the last row in the dataframe</span>
        df = pd.concat([df[df[<span class="hljs-string">'Top Brands'</span>] != <span class="hljs-string">'Others'</span>], df[df[<span class="hljs-string">'Top Brands'</span>] == <span class="hljs-string">'Others'</span>]]).reset_index(drop=<span class="hljs-literal">True</span>)
  
        <span class="hljs-comment"># Get the shapes in the current slide</span>
        shapes = prs.slides[slidenum + position].shapes
  
        <span class="hljs-comment"># Update text in specific shapes</span>
        shapes[<span class="hljs-number">4</span>].text = data_source
        shapes[<span class="hljs-number">5</span>].text = shapes[<span class="hljs-number">5</span>].text.replace(<span class="hljs-string">'National'</span>, market.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">1</span>]).replace(<span class="hljs-string">'Category'</span>, market.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>])
  
        <span class="hljs-comment"># Format the text in the shapes</span>
        shapes[<span class="hljs-number">5</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">12</span>)
        shapes[<span class="hljs-number">5</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Bold (Headings)'</span>
        shapes[<span class="hljs-number">6</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">16</span>)
        shapes[<span class="hljs-number">6</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Bold (Headings)'</span>
  
        <span class="hljs-comment"># Create tables and charts from the shapes</span>
        tables, charts = createTableAndChart(shapes)
        chart = charts[<span class="hljs-number">0</span>].chart
  
        <span class="hljs-comment"># Prepare chart data</span>
        chart_data = CategoryChartData()
        chart_data.categories = df[<span class="hljs-string">'Top Brands'</span>].tolist()
        chart_data.add_series(<span class="hljs-string">'Value Share'</span>, df[<span class="hljs-string">'Value Share'</span>])
        chart_data.add_series(<span class="hljs-string">'SKU Share'</span>, df[<span class="hljs-string">'SKU Share'</span>])
  
        <span class="hljs-comment"># Calculate the index (SKU Share / Value Share) and handle division by zero</span>
        chart_data.add_series(<span class="hljs-string">'Index'</span>, df[<span class="hljs-string">'SKU Share'</span>] / df[<span class="hljs-string">'Value Share'</span>].replace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
  
        <span class="hljs-comment"># Replace the chart data with the prepared data</span>
        chart.replace_data(chart_data)
</div></code></pre>
<hr>
<h4 id="step-4-duplicate-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Assortment%20Slide%20Duplicate/Assortment%20Duplicate.ipynb">Step 4: Duplicate Slides</a></h4>
<p><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Assortment%20Slide%20Duplicate/Assortment%20Duplicate.ipynb">Duplicate Slides</a>:generate a PowerPoint presentation with multiple sections, each containing data visualizations and tables</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Define the indexes for different sections of the presentation</span>
index = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]

<span class="hljs-comment"># Calculate the number of duplicates for each section based on the length of their respective data sets</span>
duplication = [
    len(assortmentTotalSorted.keys()),
    len(assortmentBrand.keys()),
    len(cumulativeShareTop50.keys()),
    len(assortmentClient.keys()),
    len(assortmentBrand.keys()),
    len(assortmentClientBrand.keys()),
    len(assortmentClientBrand.keys())
]

<span class="hljs-comment"># Define the names for each section of the presentation</span>
section_names = [
    <span class="hljs-string">"SKU Share By Brand"</span>,
    <span class="hljs-string">"Cumulative Product Shares"</span>,
    <span class="hljs-string">"Top 50% cumulative share"</span>,
    <span class="hljs-string">"Brand Cumulative Product Share"</span>,
    <span class="hljs-string">"Top 20 cumulative share"</span>,
    <span class="hljs-string">"SKU Productivity Analysis with TM%"</span>,
    <span class="hljs-string">"SKU Productivity Analysis with WD"</span>
]

<span class="hljs-comment"># Define paths for the base slide template and the new presentation to be created</span>
path = os.getcwd() + <span class="hljs-string">'//slide base.pptx'</span>
new_pre = os.getcwd() + <span class="hljs-string">'//slide duplicated.pptx'</span>

<span class="hljs-comment"># Initialize the position and the number of duplicates for each section</span>
position = <span class="hljs-number">0</span>

<span class="hljs-comment"># Loop through each client brand and create slides based on the provided data</span>
<span class="hljs-keyword">for</span> i, clientElement <span class="hljs-keyword">in</span> enumerate(clientBrand):
    <span class="hljs-comment"># Generate the required slides for each brand based on the calculated duplication</span>
    brandShareTopline(
        prs, 
        ToplineBracket, 
        bracketsValue, 
        int(numOfDuplicates / len(clientBrand)), 
        slide_by=columnName, 
        clientElement=clientElement, 
        position=position
    )
  
    <span class="hljs-comment"># Update the position for the next set of slides</span>
    position += int(numOfDuplicates / <span class="hljs-number">3</span>)

<span class="hljs-comment"># Increment the section position</span>
sectionPosition += <span class="hljs-number">1</span>

<span class="hljs-comment"># Define the path for saving the output presentation</span>
outputPath = os.getcwd() + <span class="hljs-string">'\\'</span> + columnName + <span class="hljs-string">" output.pptx"</span>

<span class="hljs-comment"># Save the PowerPoint presentation to the specified output path</span>
prs.save(outputPath)

<span class="hljs-comment"># Use the win32 library to open the saved PowerPoint presentation</span>
app = win32.Dispatch(<span class="hljs-string">"PowerPoint.Application"</span>)
presentation = app.Presentations.Open(outputPath)
</div></code></pre>
<hr>
<h4 id="step-5-replace-data-in-slide"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Assortment%20Slide%20Duplicate/Assortment%20Duplicate.ipynb">Step 5: Replace Data in Slide</a></h4>
<ul>
<li>Generate the slides for SKU Share By Brand using the provided data.
<ul>
<li>prs: The PowerPoint presentation object where slides will be added or modified.</li>
<li>assortmentTotalSorted: The data set containing SKU share information, sorted accordingly.</li>
<li>duplication[0]: The number of duplicates to create for this section, specified by the first element in the duplication list.</li>
<li>position=0: The starting position for slide creation in this section.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>SkuShareByBrand(prs, assortmentTotalSorted, duplication[<span class="hljs-number">0</span>], position=<span class="hljs-number">0</span>)
</div></code></pre>
<h4 id="step-6-save-presentation"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Assortment%20Slide%20Duplicate/Assortment%20Duplicate.ipynb">Step 6: Save Presentation</a></h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Set the output path for the PowerPoint presentation</span>
outputPath = os.getcwd() + <span class="hljs-string">"\\Mix and assortment doc output.pptx"</span>

<span class="hljs-comment"># Save the current PowerPoint presentation to the specified path</span>
prs.save(outputPath)

<span class="hljs-comment"># Open the saved PowerPoint presentation using the PowerPoint application</span>
app = win32.Dispatch(<span class="hljs-string">"PowerPoint.Application"</span>)
presentation = app.Presentations.Open(outputPath)
</div></code></pre>
<hr>
<h5 id="example-output-slide-after-replacement-data-%22sku-share-by-brand%22">Example: OutPut Slide After Replacement Data &quot;SKU Share By Brand&quot;</h5>
<p>![SKU Share By Brand](../Slides Documantion/assortment output slide.png)</p>
<hr>
<h2 id="promotion-section">Promotion Section</h2>
<h3 id="introduction">Introduction</h3>
<p>In slide automation Promotion Section using 20 basic slides we have created 17 sections</p>
<ul>
<li>Promo Value Sales</li>
<li>Promo Evolution</li>
<li>VSOD Summary</li>
<li>Value uplift by retailer by brand</li>
<li>Volume Uplift vs discount depth</li>
<li>Value Uplift vs Promo Efficiency Quadrant</li>
<li>Top 20 promotions</li>
<li>Top 20 promotions CLIENT ONLY</li>
<li>Bottom 20 promotions CLIENT ONLY</li>
<li>Volume Sold on Deal</li>
<li>Promo share vs Value Share</li>
<li>Promo Sales by total size</li>
<li>Promo Frequency learnings</li>
<li>Category Promo sales per retailer</li>
<li>Sector Promo sales per retailer</li>
<li>Segment Promo sales per retailer</li>
<li>Value Uplift vs discount depth</li>
</ul>
<hr>
<h3 id="project-steps">Project Steps</h3>
<ul>
<li>Project Flow
![Project Flow](../Slides Documantion/duplication_Steps.PNG)</li>
</ul>
<ul>
<li><a href="#step-1-import-libraries">Step 1: Import Libraries we use</a></li>
<li><a href="#step-2-modified-data-frame">Step 2: modified Data frames: cleaning and preprocessing the data frames</a></li>
<li><a href="#step-3-write-functions-to-create-slide">Step 3: Write Functions to Create Slides: Define functions to dynamically generate slides based on the base slides</a></li>
<li><a href="#step-4-duplicate-slides">Step 4: Duplicate Slides: Use functions or methods to duplicate existing slides as needed for the presentation.</a></li>
<li><a href="#step-5-replace-data-in-slide">Step 5: Replace Data in Slide: update information from the cleaned data frames to slides</a></li>
<li><a href="#step-6-save-presentation">Step 6: Save Presentation</a></li>
</ul>
<hr>
<h4 id="step-1-import-libraries-we-use"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/generalFunctions.ipynb">Step 1: Import Libraries we use </a></h4>
<h5 id="ex-libraries-we-use">Ex: Libraries we use</h5>
<ul>
<li>This script sets up an environment for working with PowerPoint presentations, data manipulation, filesystem operations, and COM (Component Object Model) object access.</li>
<li>It imports necessary modules such as 'pptx' for PowerPoint automation, 'win32com' for COM object access and Windows automation, 'pandas' and 'numpy' for data manipulation,</li>
<li>'pathlib' for working with filesystem paths, 're' for regular expression operations, and various other modules for general-purpose tasks like file operations and timing functions.</li>
<li>By importing these modules, the script prepares itself for tasks such as creating or modifying PowerPoint presentations, analyzing data using pandas and numpy, interacting</li>
<li>with the Windows environment using win32com, and performing filesystem operations using shutil and os. Overall, this script provides a comprehensive setup for automating tasks</li>
<li>related to PowerPoint presentations and general-purpose Python programming.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Import necessary module for working with PowerPoint presentations</span>
<span class="hljs-keyword">from</span> pptx <span class="hljs-keyword">import</span> Presentation
<span class="hljs-comment"># Import the win32com.client module, aliasing it as win32 for convenience</span>
<span class="hljs-keyword">import</span> win32com.client <span class="hljs-keyword">as</span> win32
<span class="hljs-comment"># Import pandas for data manipulation and analysis</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># Import numpy for numerical computing</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># Import the Path class from pathlib for working with filesystem paths</span>
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-comment"># Import re for regular expression operations</span>
<span class="hljs-keyword">import</span> re
<span class="hljs-comment"># Import sys for access to interpreter-related functions</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-comment"># Import time for various time-related functions</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-comment"># Assign win32.constants to a shorter alias win32c for easier access</span>
win32c = win32.constants
<span class="hljs-comment"># Import shutil for high-level file operations</span>
<span class="hljs-keyword">import</span> shutil
<span class="hljs-comment"># Import os for operating system dependent functionality</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-comment"># Import win32com.client again for COM object and functions access</span>
<span class="hljs-keyword">import</span> win32com.client
<span class="hljs-comment"># Import warnings for warning control functionality</span>
<span class="hljs-keyword">import</span> warnings
</div></code></pre>
<hr>
<h4 id="step-2-modified-data-frame"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Promotion%20Slide%20Duplicate/Promotion%20Duplicate.ipynb">Step 2: modified Data frame</a></h4>
<h5 id="ex-input-dataframes-before-cleaning">EX: input dataframes before cleaning</h5>
<p>![Promotion data frame before Cleaning ](../Slides Documantion/PPA input data frame .png)</p>
<hr>
<h5 id="cleaning-data-frame">Cleaning Data Frame</h5>
<ul>
<li><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Promotion%20Slide%20Duplicate/Promotion%20Duplicate.ipynb">cleaningData function</a>: Clean and preprocess data in a dictionary of DataFrames.
<ul>
<li>Parameters:
data (dict): Dictionary containing DataFrames.</li>
<li>Returns:
dict: Dictionary containing cleaned DataFrames.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cleaningData</span><span class="hljs-params">(data)</span>:</span>
    cleaned_data = {}
    <span class="hljs-comment"># Iterate over each key-value pair in the input dictionary</span>
    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> data:
        <span class="hljs-comment"># Skip the first 11 rows if there are NaN values</span>
        df = data[key].iloc[<span class="hljs-number">11</span>:]
        <span class="hljs-keyword">if</span> data[key].iloc[<span class="hljs-number">11</span>,:].isna().any():
            df = data[key].iloc[<span class="hljs-number">12</span>:]
        <span class="hljs-comment"># Set column names and skip the first row</span>
        df.columns = df.iloc[<span class="hljs-number">0</span>]
        df = df.iloc[<span class="hljs-number">1</span>:]
        <span class="hljs-comment"># Perform specific cleaning operations based on the DataFrame columns and key</span>
        <span class="hljs-keyword">if</span> df.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-string">'National'</span> <span class="hljs-keyword">in</span> key:
            <span class="hljs-keyword">if</span> <span class="hljs-string">'Top Brands'</span> <span class="hljs-keyword">in</span> df.columns <span class="hljs-keyword">and</span> <span class="hljs-string">'Product'</span> <span class="hljs-keyword">in</span> df.columns:
                df[<span class="hljs-string">'Top Brands'</span>] = df[<span class="hljs-string">'Top Brands'</span>].fillna(method=<span class="hljs-string">'ffill'</span>)
                df[<span class="hljs-string">'Product'</span>].fillna(<span class="hljs-string">''</span>, inplace=<span class="hljs-literal">True</span>)
                df.fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>)
                df[<span class="hljs-string">'Top Brands'</span>] = df[<span class="hljs-string">'Top Brands'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'Grand Total'</span> <span class="hljs-keyword">if</span> <span class="hljs-string">'Grand Total'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> x.replace(<span class="hljs-string">'Total'</span>, <span class="hljs-string">''</span>).strip())
            <span class="hljs-keyword">elif</span> <span class="hljs-string">'Top Brands'</span> <span class="hljs-keyword">in</span> df.columns:
                df[<span class="hljs-string">'Top Brands'</span>] = df[<span class="hljs-string">'Top Brands'</span>].fillna(method=<span class="hljs-string">'ffill'</span>)
                df.fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>)
                df[<span class="hljs-string">'Top Brands'</span>] = df[<span class="hljs-string">'Top Brands'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'Grand Total'</span> <span class="hljs-keyword">if</span> <span class="hljs-string">'Grand Total'</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> x.replace(<span class="hljs-string">'Total'</span>, <span class="hljs-string">''</span>).strip())
                df = df[~df[<span class="hljs-string">'Top Brands'</span>].str.contains(<span class="hljs-string">'Total'</span>, case=<span class="hljs-literal">False</span>)]
                df = df[df[<span class="hljs-string">'Total Size'</span>] == <span class="hljs-number">0</span>].reset_index(drop=<span class="hljs-literal">True</span>)
                df[<span class="hljs-string">'VSOD Evaluation vs YA'</span>]=df[<span class="hljs-string">'VSOD IYA'</span>]<span class="hljs-number">-1</span>
                df[<span class="hljs-string">'Promo Value Uplift vs YA'</span>]=df[<span class="hljs-string">'Value Uplift Normalized IYA'</span>]<span class="hljs-number">-1</span>

            <span class="hljs-keyword">elif</span> <span class="hljs-string">'End of Week'</span> <span class="hljs-keyword">in</span> df.columns <span class="hljs-keyword">and</span> <span class="hljs-string">'Product'</span> <span class="hljs-keyword">in</span> df.columns:
                df[<span class="hljs-string">'Product'</span>] = df[<span class="hljs-string">'Product'</span>].fillna(method=<span class="hljs-string">'ffill'</span>)
                df = df[(df[<span class="hljs-string">'End of Week'</span>].str.contains(<span class="hljs-string">'2023|2024'</span>)) &amp; (df[<span class="hljs-string">'End of Week'</span>].notna())]
                df[<span class="hljs-string">'End of Week'</span>] = pd.to_datetime(df[<span class="hljs-string">'End of Week'</span>])
                df = df[(df[<span class="hljs-string">'End of Week'</span>] &gt;= start_date) &amp; (df[<span class="hljs-string">'End of Week'</span>] &lt;= end_date)]
                df = df[~df[<span class="hljs-string">'Product'</span>].str.contains(<span class="hljs-string">'Total'</span>, case=<span class="hljs-literal">False</span>)].reset_index(drop=<span class="hljs-literal">True</span>)
                df = df[df[<span class="hljs-string">'Promo Sales'</span>] &gt; <span class="hljs-number">10000</span>]
                df = df.dropna(subset=[<span class="hljs-string">'Value Uplift (v. base) Normalized'</span>])
                df.fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>)
                df = df.reset_index(drop=<span class="hljs-literal">True</span>)
        
            <span class="hljs-keyword">elif</span> <span class="hljs-string">'End of Week'</span> <span class="hljs-keyword">in</span> df.columns:
                df[<span class="hljs-string">'End of Week'</span>] = df[<span class="hljs-string">'End of Week'</span>].astype(str)
                df = df[~df[<span class="hljs-string">'End of Week'</span>].str.contains(<span class="hljs-string">'Total'</span>, case=<span class="hljs-literal">False</span>)].reset_index(drop=<span class="hljs-literal">True</span>)
                df[<span class="hljs-string">'End of Week'</span>] = pd.to_datetime(df[<span class="hljs-string">'End of Week'</span>])
                df[<span class="hljs-string">'End of Week'</span>] = df[<span class="hljs-string">'End of Week'</span>].dt.strftime(<span class="hljs-string">"%d-%b-%y"</span>)
                df = df[(df[<span class="hljs-string">'End of Week'</span>].str.contains(<span class="hljs-string">'-21|-22|-23|Jan-24'</span>)) &amp; (df[<span class="hljs-string">'End of Week'</span>].notna())]
                df[<span class="hljs-string">'End of Week'</span>] = pd.to_datetime(df[<span class="hljs-string">'End of Week'</span>])
                df = df[(df[<span class="hljs-string">'End of Week'</span>] &gt;= start_date) &amp; (df[<span class="hljs-string">'End of Week'</span>] &lt;= end_date)]
                df = df.dropna()
        
            <span class="hljs-keyword">elif</span> <span class="hljs-string">'Grand Total'</span> <span class="hljs-keyword">in</span> df.columns:
                df.fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>)
            <span class="hljs-comment"># Check if the key matches specific categories and modify the key accordingly</span>
            <span class="hljs-keyword">if</span> key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> categories <span class="hljs-keyword">and</span> len(key.split(<span class="hljs-string">' | '</span>)) == <span class="hljs-number">3</span>:
                modified_key = key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">' | '</span> + key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">2</span>] + <span class="hljs-string">' | '</span> + key.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>]
                <span class="hljs-keyword">if</span> df.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>:
                    cleaned_data[modified_key] = df
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> df.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>:
                    cleaned_data[key] = df
    <span class="hljs-keyword">return</span> cleaned_data
</div></code></pre>
<hr>
<h5 id="example-out-put-data-frame-after-cleaning">Example: out put data frame after cleaning</h5>
<p>![out put data frame after cleaning ](../Slides Documantion/promotion output  data frame .png)</p>
<hr>
<h4 id="step-3-write-functions-to-create-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/Promotion%20Slide%20Duplicate/Promotion%20Duplicate.ipynb">Step 3: Write Functions to Create Slides</a></h4>
<h5 id="example-slide--promo-value-sales-base-slide">Example slide : Promo Value Sales base slide</h5>
<p>![Promo Value Sales ](../Slides Documantion/promotion base slide .png)</p>
<hr>
<h5 id="replacement-function">Replacement function</h5>
<ul>
<li><a href="">promoValueSales function</a>:Generate PowerPoint slides for promo value sales</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">promoValueSales</span><span class="hljs-params">(prs, promotionsBrandDF, numOfDuplicates, position=<span class="hljs-number">0</span>)</span>:</span>
    <span class="hljs-comment"># Loop through each slide number</span>
    <span class="hljs-keyword">for</span> slidenum <span class="hljs-keyword">in</span> range(numOfDuplicates):
        <span class="hljs-comment"># Get market from promotionsBrandDF keys</span>
        market = list(promotionsBrandDF.keys())[slidenum]
        <span class="hljs-comment"># Retrieve DataFrame for the current market</span>
        df = promotionsBrandDF[market].reset_index(drop=<span class="hljs-literal">True</span>)
        <span class="hljs-comment"># Remove rows with 'Others' in 'Top Brands' column and filter by 'Value Share'</span>
        df = df[~df[<span class="hljs-string">'Top Brands'</span>].str.contains(<span class="hljs-string">'Others'</span>, case=<span class="hljs-literal">False</span>)]
        df = df[df[<span class="hljs-string">'Value Share'</span>] &gt; <span class="hljs-number">0.01</span>]
        <span class="hljs-comment"># Select client brands</span>
        df_client = selectClientBrands(promotionsBrandDF[market],<span class="hljs-string">'Top Brands'</span>, <span class="hljs-string">'Promo Value'</span>)
        number_of_brands_needed = <span class="hljs-number">5</span> - len(df_client)
        <span class="hljs-comment"># Filter top brands and concatenate with client brands</span>
        df = df[~df[<span class="hljs-string">'Top Brands'</span>].isin(client_brands)]
        df = df.sort_values(by=<span class="hljs-string">'Promo Value'</span>, ascending=<span class="hljs-literal">False</span>).head(number_of_brands_needed)
        df = pd.concat([df, df_client], ignore_index=<span class="hljs-literal">True</span>)
        df = df.sort_values(by=<span class="hljs-string">'Promo Value'</span>, ascending=<span class="hljs-literal">False</span>)
        <span class="hljs-comment"># Update title</span>
        shapes = prs.slides[slidenum + position].shapes
        titlNumber = get_shape_number(shapes, <span class="hljs-string">"Promo Value Sales | Category | National | P12M"</span>)
        shapes[titlNumber - <span class="hljs-number">1</span>].text = data_source
        shapes[titlNumber + <span class="hljs-number">1</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">16</span>)
        shapes[titlNumber + <span class="hljs-number">1</span>].text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Bold (Headings)'</span>
        shapes[titlNumber].text = shapes[titlNumber].text.replace(<span class="hljs-string">'Category'</span>, market.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">0</span>]).replace(
            <span class="hljs-string">'National'</span>, market.split(<span class="hljs-string">' | '</span>)[<span class="hljs-number">1</span>])
        shapes[titlNumber].text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">12</span>)
        shapes[titlNumber].text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Bold (Headings)'</span>
        <span class="hljs-comment"># Create table and chart</span>
        tables, charts = createTableAndChart(shapes)
        table = tables[<span class="hljs-number">0</span>].table
  
        <span class="hljs-comment"># Remove unnecessary rows</span>
        num_rows_to_remove = len(table.rows) - df[<span class="hljs-string">'Top Brands'</span>].nunique() - <span class="hljs-number">1</span>
        table_height = get_table_height(table)
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(num_rows_to_remove):
            <span class="hljs-keyword">if</span> len(table.rows) &gt; <span class="hljs-number">1</span>:
                row = table.rows[<span class="hljs-number">1</span>]
                remove_row(table, row)
  
        <span class="hljs-comment"># Adjust row heights</span>
        total_row_height = table_height - table.rows[<span class="hljs-number">0</span>].height
        num_rows = len(table.rows) - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> num_rows &gt; <span class="hljs-number">0</span>:
            cell_height = total_row_height / num_rows
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, table.rows.__len__()):
                table.rows[row].height = int(cell_height)
        <span class="hljs-comment"># Populate table cells</span>
        <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> enumerate(table.rows):
            <span class="hljs-keyword">for</span> j, cell <span class="hljs-keyword">in</span> enumerate(row.cells):
                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># Header row</span>
                    <span class="hljs-keyword">continue</span>
                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:  <span class="hljs-comment"># Brand column</span>
                    cell.text = df[<span class="hljs-string">'Top Brands'</span>].iloc[i - <span class="hljs-number">1</span>]
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Bold'</span>
                <span class="hljs-keyword">elif</span> j == <span class="hljs-number">1</span>:  <span class="hljs-comment"># Promo Value sales column</span>
                    value = df[<span class="hljs-string">'Promo Value'</span>].iloc[i - <span class="hljs-number">1</span>]
                    <span class="hljs-keyword">if</span> len(str(value)) &gt; <span class="hljs-number">3</span>:
                        formatted_value = <span class="hljs-string">'{:,}'</span>.format(int(value))
                        cell.text = str(formatted_value)
                        cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Book'</span>
                    <span class="hljs-keyword">else</span>:
                        cell.text = str(df[<span class="hljs-string">'Promo Value'</span>].iloc[i - <span class="hljs-number">1</span>])
                        cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Book'</span>
                <span class="hljs-keyword">elif</span> j == <span class="hljs-number">2</span>:  <span class="hljs-comment"># Volume Sold on Deal (VSOD) column</span>
                    cell.text = str(int(round(df[<span class="hljs-string">'VSOD'</span>].replace(np.nan, <span class="hljs-number">0</span>).iloc[i - <span class="hljs-number">1</span>] * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>))) + <span class="hljs-string">'%'</span>
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Book'</span>
                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># VSOD IYA column</span>
                    cell.text = str(int(round(df[<span class="hljs-string">'VSOD IYA'</span>].replace(np.nan, <span class="hljs-number">0</span>).iloc[i - <span class="hljs-number">1</span>] * <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)))
                    cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.name = <span class="hljs-string">'Nexa Book'</span>
                <span class="hljs-comment"># Set font size and alignment</span>
                cell.text_frame.paragraphs[<span class="hljs-number">0</span>].font.size = Pt(<span class="hljs-number">8</span>)
                cell.text_frame.paragraphs[<span class="hljs-number">0</span>].alignment = PP_ALIGN.CENTER
</div></code></pre>
<hr>
<h4 id="step-4-duplicate-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Promotion%20Replacement%20Function.ipynb">Step 4: Duplicate Slides</a>:</h4>
<ul>
<li>This code generates indices, duplication factors, and section names for PowerPoint slides</li>
<li>based on different promotional data sources. It sets up paths for the base and duplicated slides,</li>
<li>and ensures the correct indices and duplication values for each section of the presentation.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Generate indices for slides containing promo value data for different categories, sectors, and segments</span>
slidePromoValueIndex = [
    [i + <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> catDuplication.values()],  <span class="hljs-comment"># Adjust category duplication indices by adding 15</span>
    [i + <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> secDuplication.values()],  <span class="hljs-comment"># Adjust sector duplication indices by adding 15</span>
    [i + <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> segDuplication.values()]   <span class="hljs-comment"># Adjust segment duplication indices by adding 15</span>
]
<span class="hljs-comment"># Create a list of slide indices, conditional on the presence of promo type, feature share, and display share data</span>
index = [
    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, 
    <span class="hljs-number">12</span> <span class="hljs-keyword">if</span> promo_type != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional index for promo type</span>
    <span class="hljs-number">13</span> <span class="hljs-keyword">if</span> feature_share != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional index for feature share</span>
    <span class="hljs-number">14</span> <span class="hljs-keyword">if</span> display_share != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional index for display share</span>
    <span class="hljs-number">15</span>, *slidePromoValueIndex, <span class="hljs-number">20</span>  <span class="hljs-comment"># Base index 15, adjusted promo value indices, and final index 20</span>
]
<span class="hljs-comment"># Remove None values from the index list</span>
index = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> index <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]
<span class="hljs-comment"># Calculate the lengths of various datasets</span>
len_brands = len(modified_promotionBrandsP12M)
len_Prod = len(modified_promotionProductsP12M)
len_modified_prod = len(new_modified_promotionProductsP12M)
len_client_market = len(client_brands) * len(regions_RET)
<span class="hljs-comment"># Define duplication factors for each section based on the lengths of relevant datasets</span>
duplication = [
    len_brands, len(promotionsBrandSortedTotal), len(promotionsBrandsWithMarket), len(concated), 
    len_Prod, len_modified_prod, len_modified_prod, len(top20clientonly), len(bottom20clientonly),
    len_client_market, len_brands, len(newModifiedBrands), 
    len(newModifiedBrands) <span class="hljs-keyword">if</span> promo_type != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional duplication factor for promo type</span>
    len_brands <span class="hljs-keyword">if</span> feature_share != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional duplication factor for feature share</span>
    len_brands <span class="hljs-keyword">if</span> display_share != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional duplication factor for display share</span>
    len(modified_promotionEndOfWeek), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,
    <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional duplication factor for segments</span>
    len(modified_valueUplift)
]

<span class="hljs-comment"># Remove None values from the duplication list</span>
duplication = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> duplication <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]

<span class="hljs-comment"># Define section names for each part of the presentation</span>
section_names = [
    <span class="hljs-string">"Promo Value Sales"</span>, <span class="hljs-string">"Promo Evolution"</span>, <span class="hljs-string">"VSOD Summary"</span>, <span class="hljs-string">"Value uplift by retailer by brand"</span>,
    <span class="hljs-string">"Volume Uplift vs discount depth"</span>, <span class="hljs-string">"Value Uplift vs Promo Efficiency Quadrant"</span>, <span class="hljs-string">"Top 20 promotions"</span>,
    <span class="hljs-string">"Top 20 promotions CLIENT ONLY"</span>, <span class="hljs-string">"Bottom 20 promotions CLIENT ONLY"</span>, <span class="hljs-string">"Volume Sold on Deal"</span>,
    <span class="hljs-string">"Promo share vs Value Share"</span>, <span class="hljs-string">"Promo Sales by total size"</span>,
    <span class="hljs-string">"Promo Sales by promo type"</span> <span class="hljs-keyword">if</span> promo_type != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional section name for promo type</span>
    <span class="hljs-string">"Feature Share vs Fair Share"</span> <span class="hljs-keyword">if</span> feature_share != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional section name for feature share</span>
    <span class="hljs-string">"Display Share vs Fair Share"</span> <span class="hljs-keyword">if</span> display_share != <span class="hljs-literal">False</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional section name for display share</span>
    <span class="hljs-string">"Promo Frequency learnings"</span>, <span class="hljs-string">"Category Promo sales per retailer"</span>, <span class="hljs-string">"Sector Promo sales per retailer"</span>,
    <span class="hljs-string">"Segment Promo sales per retailer"</span> <span class="hljs-keyword">if</span> len(segments) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Conditional section name for segments</span>
    <span class="hljs-string">"Value Uplift vs discount depth"</span>
]
<span class="hljs-comment"># Remove None values from the section names list</span>
section_names = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> section_names <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]

<span class="hljs-comment"># Define paths for the base PowerPoint file and the duplicated PowerPoint file</span>
path = os.getcwd() + <span class="hljs-string">'//slide base.pptx'</span>
new_pre = os.getcwd() + <span class="hljs-string">'//slide duplicated.pptx'</span>

<span class="hljs-comment"># Define the data source string to be used in the presentation</span>
data_source = <span class="hljs-string">"DATA SOURCE: Trade Panel/Retailer Data | Ending Jan 2024"</span>
</div></code></pre>
<hr>
<h4 id="step-5-replace-data-in-slides"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Promotion%20Replacement%20Function.ipynb">Step 5: Replace Data in Slides</a></h4>
<ul>
<li>Call the promoValueSales function to generate slides for promotional value sales</li>
<li>prs: PowerPoint presentation object</li>
<li>modified_promotionBrandsP12M: Dictionary containing promotion data for different markets</li>
<li>duplication[posItr]: Number of slides to duplicate for the current market</li>
<li>position=posItr: Starting position to add slides in the presentation</li>
</ul>
<pre class="hljs"><code><div>promoValueSales(prs, modified_promotionBrandsP12M, duplication[posItr], position=posItr)

<span class="hljs-comment"># Increment the position iterator by 1 to move to the next section for the next function call</span>
posItr += <span class="hljs-number">1</span>
</div></code></pre>
<h4 id="step-6-save-presentation"><a href="https://github.com/khaledSeifEleslam/Slide-Automate/blob/main/general_functions/Promotion%20Replacement%20Function.ipynb">Step 6: Save Presentation</a></h4>
<ul>
<li>performs two main tasks: saving the current PowerPoint presentation to a file and opening that file using the PowerPoint application. The outputPath variable is constructed using the current working directory, ensuring the presentation is saved in the correct location. After saving the presentation, the script uses win32com.client to dispatch the PowerPoint application and open the saved presentation. This automation allows for seamless transition from generating the presentation to viewing or editing it in PowerPoint, streamlining the workflow for creating market analysis slides.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># This script saves the generated PowerPoint presentation to a specified path</span>
<span class="hljs-comment"># and then opens the saved presentation using the PowerPoint application.</span>

<span class="hljs-comment"># Define the output path for the PowerPoint presentation</span>
outputPath=os.getcwd() + <span class="hljs-string">"\\Promotion doc output.pptx"</span>

<span class="hljs-comment"># Save the PowerPoint presentation to the specified output path</span>
prs.save(outputPath)

<span class="hljs-comment"># Initialize the PowerPoint application using win32com client</span>
app = win32.Dispatch(<span class="hljs-string">"PowerPoint.Application"</span>)

<span class="hljs-comment"># Open the saved PowerPoint presentation</span>
presentation = app.Presentations.Open(outputPath)
</div></code></pre>
<hr>
<h5 id="example-slide--promo-value-sales-slide-after-replacement">Example slide : Promo Value Sales slide after replacement</h5>
<p>![Promo Value Sales](../Slides Documantion/promotion output slide .png)</p>

</body>
</html>
